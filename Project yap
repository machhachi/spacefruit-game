
# Clear out app.playerPos and make it a list
# maybe I can forgo the dictionary definition I think it's fine


# === TO DO ===
# Implement gravitation
#   Don't do between all bodies, figure out classes so that some give and some recieve
# 
# Implement Collision
# The hardest work the ship / fruit end wants to do (for now the only planet-colliders) is know If It's Colliding.
# Then, it wants to be given a collision return direction. That is literally all.

# So, working top down, we will design a function that checks if it's colliding, and if so, returns the direct vector to the edge. (It's normal).
#   (This lets us do two things. For slow / inelastic collisions, we simply teleport along that vector, so we're just at the surface)
#   (For fast / elastic collisions, we turn that into a unit vector, and reverse the component of velocity going in the negative of that direction)
#       (I thought of this a bit ago: we only want to have our direction flipped if we're going towards the inside of the shape)
#       (This prevents rubber banding of adding more and more speed once we're already on our way outwards)
#       (Then again we could simply teleport to the edge for any collision, but we should do that as well as what I'm now describing)
#       (Yadda yadda, take the dot product of the collision normal vector and velocity, if negative (thing going further into planet) THEN flip it)
#                               (do nothing otherwise)

# This collision function will compare the player's centerpoint (I like center, as opposed to foot point as mike mentioned) to a Collision Mesh
# The collision mesh is the floor mesh, raised by the player's radius, such that intersecting / being in it counts as touching the planet
# This code now depends on the type of mesh we have. But both can easily identify a point on their interior and both can return the best outward normal

# Spherical meshes are the first type. (And easier)
# Their planet is a ball, and the collision mesh is simply the ball raised by the player's radius.
# Checking internality is as simple as asking if the centerpoint distance is less than the collision ball's radius.
# And then, the return vector is the collision radius minus the centerpoint radius. 
#   (Convert comp-wise to hypotenuse and angle) (Straight radius minus hypotenuse gives leftover) (Convert leftover back to components)

# Linear meshes are the second type. (I think I got this down)
# I like to call them linear, but these are more specifically arbitrary n-polygons. I imagine them best as a collection of lines.
# Most specifically, they are just a collection of points (wound ccw let's say). Lines are drawn between those as the planet.

# First, we must check if we are inside the line-gon
# I'll go through two proposed solutions: the Taylor raycaster and the Lague dotprod
#   The Taylor raycaster is a standard seeming solution, you draw lines radiating from the player
#   And count the number of times they intersect the lines of the planet-gon
#       One should always get an odd number of intersections to be inside the thing
#       This accounts for concavities, so the line can enter and exit so long as there is always a net single exit
#       This is agnostic to the alignment of points, which is nice
#       An agreeing majority vote of odd-ness (add 1 for each odd intersection total, subtract 1 for even, check if positive) should iron out edge cases
#       And there you have it: you're intersecting

#       Maybe relevant: https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/

#   The Lague dot product is a neat trick that is practical for rendering triangles (I suspect complexity ups wildly with line count)
#       The dotprod method seeks to find whether a point is equally on the left or right of the three sides of a triangle
#       Now the left or right of a line is not awfully clear, but that is only 90 degrees off from in alignment with the forward direction of a line
#       So this takes the direction vector along a line, rotated 90, dotted with the vector from that line to the test point
#       This dot product will be positive if internal and negative if external, depending on winding order
#       And if all values agree in the triangle, then it is within

#       Unfortunately this seems difficult to generalize to arbitrary polygons
#       I think this is a case where concavities become very difficult
#       The math is cool, but I think puting together an effective raycasting is better

#       Plus, raycasting (with sufficient resolution) gives us an answer to the closest wall, which is useful

# So we know we are inside the line-gon. Excellent. Now, we must get the side we entered from, and know its normal vector.
#   Realistically, this is the current closest side. Our speeds won't be so unfathomably high that we will burrow into line-gons and pass through.
#   As we iterate through the raycaster, we should store the closest point of intersection to the player, and its accompanying line.

#   Once we're done determining our inside-ness of the line-gon, we refer back to the closest line.
#   Ideally, we calculate the perpendicular distance vector between our closest line and the player point.
#
# This is the distance vector to the surface.
# In fact, we now know the return vector that we wanted all along.


# So now, in both cases, we have determined that we are colliding, and we know the path there.

# We now chooes between two types of collision



# Practical wants
# Don't render objects if they're too far ( radius of rendering )
# How to globalize scale? (Just pass app variables to everything, as Mike put it, "import *" is like it pastes the WHOLE block)

# === Distant Wants
# Outer Wilds style minimap of the world that can be panned through
# Fruit objects that can be collision physics bodies, spheres, and roll about
# Fruit fall off of trees
# Miniature allies / enemies that can fly around in your vicinity and are reasonable at navigating
# 
