# Spacefruit the Game
# Main file
# By Alexander Werth
# Andrew ID: awerth2
# Recitation: U


from cmu_graphics import *
import math

# Clear out app.playerPos and make it a list
# maybe I can forgo the dictionary definition I think it's fine


# === TO DO ===
# Implement gravitation
#   Don't do between all bodies, figure out classes so that some give and some recieve
# 
# Implement Collision
# The hardest work the ship / fruit end wants to do (for now the only planet-colliders) is know If It's Colliding.
# Then, it wants to be given a collision return direction. That is literally all.

# So, working top down, we will design a function that checks if it's colliding, and if so, returns the direct vector to the edge. (It's normal).
#   (This lets us do two things. For slow / inelastic collisions, we simply teleport along that vector, so we're just at the surface)
#   (For fast / elastic collisions, we turn that into a unit vector, and reverse the component of velocity going in the negative of that direction)
#       (I thought of this a bit ago: we only want to have our direction flipped if we're going towards the inside of the shape)
#       (This prevents rubber banding of adding more and more speed once we're already on our way outwards)
#       (Then again we could simply teleport to the edge for any collision, but we should do that as well as what I'm now describing)
#       (Yadda yadda, take the dot product of the collision normal vector and velocity, if negative (thing going further into planet) THEN flip it)
#                               (do nothing otherwise)

# This collision function will compare the player's centerpoint (I like center, as opposed to foot point as mike mentioned) to a Collision Mesh
# The collision mesh is the floor mesh, raised by the player's radius, such that intersecting / being in it counts as touching the planet
# This code now depends on the type of mesh we have. But both can easily identify a point on their interior and both can return the best outward normal

# Spherical meshes are the first type. (And easier)
# Their planet is a ball, and the collision mesh is simply the ball raised by the player's radius.
# Checking internality is as simple as asking if the centerpoint distance is less than the collision ball's radius.
# And then, the return vector is the collision radius minus the centerpoint radius. 
#   (Convert comp-wise to hypotenuse and angle) (Straight radius minus hypotenuse gives leftover) (Convert leftover back to components)

# Linear meshes are the second type. (I think I got this down)
# I like to call them linear, but these are more specifically arbitrary n-polygons. I imagine them best as a collection of lines.
# Most specifically, they are just a collection of points (wound ccw let's say). Lines are drawn between those as the planet.

# First, we must check if we are inside the line-gon
# I'll go through two proposed solutions: the Taylor raycaster and the Lague dotprod
#   The Taylor raycaster is a standard seeming solution, you draw lines radiating from the player
#   And count the number of times they intersect the lines of the planet-gon
#       One should always get an odd number of intersections to be inside the thing
#       This accounts for concavities, so the line can enter and exit so long as there is always a net single exit
#       This is agnostic to the alignment of points, which is nice
#       An agreeing majority vote of odd-ness (add 1 for each odd intersection total, subtract 1 for even, check if positive) should iron out edge cases
#       And there you have it: you're intersecting

#       Maybe relevant: https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/

#   The Lague dot product is a neat trick that is practical for rendering triangles (I suspect complexity ups wildly with line count)
#       The dotprod method seeks to find whether a point is equally on the left or right of the three sides of a triangle
#       Now the left or right of a line is not awfully clear, but that is only 90 degrees off from in alignment with the forward direction of a line
#       So this takes the direction vector along a line, rotated 90, dotted with the vector from that line to the test point
#       This dot product will be positive if internal and negative if external, depending on winding order
#       And if all values agree in the triangle, then it is within

#       Unfortunately this seems difficult to generalize to arbitrary polygons
#       I think this is a case where concavities become very difficult
#       The math is cool, but I think puting together an effective raycasting is better

#       Plus, raycasting (with sufficient resolution) gives us an answer to the closest wall, which is useful

# So we know we are inside the line-gon. Excellent. Now, we must get the side we entered from, and know its normal vector.
#   Realistically, this is the current closest side. Our speeds won't be so unfathomably high that we will burrow into line-gons and pass through.
#   As we iterate through the raycaster, we should store the closest point of intersection to the player, and its accompanying line.

#   Once we're done determining our inside-ness of the line-gon, we refer back to the closest line.
#   Ideally, we calculate the perpendicular distance vector between our closest line and the player point.
#
# This is the distance vector to the surface.
# In fact, we now know the return vector that we wanted all along.


# So now, in both cases, we have determined that we are colliding, and we know the path there.

# We now chooes between two types of collision



# Practical wants
# Don't render objects if they're too far ( radius of rendering )
# How to globalize scale? (Just pass app variables to everything, as Mike put it, "import *" is like it pastes the WHOLE block)

# === Distant Wants
# Outer Wilds style minimap of the world that can be panned through
# Fruit objects that can be collision physics bodies, spheres, and roll about
# Fruit fall off of trees
# Miniature allies / enemies that can fly around in your vicinity and are reasonable at navigating
# 

# === APP INITIALIZATION

def onAppStart(app):
    setRenderOrigin(app)

    # Game state
    app.stepsPerSecond = 30
    app.scale = 1

    # Player behavior
    app.Thrusting = False
    app.directionScaleChange = 1

    app.playerThrustConstant = 0.1
    app.playerTwistConstant = 0.1

    # Objects
    app.objectOnePos = [600, 200, 0]


# === OBJECT DEFINITION ===

class CollisionObject(): # Let's assume size
    def __init__(self, pos, size):
        self.pos = pos
        self.size = size

class SmallBody(CollisionObject):
    def __init__(self, pos, vel, size, mass):
        self.pos = pos
        self.vel = vel
        self.size = size
        self.mass = mass

class SpherePlanet():
    def __init__(self, pos, vel, mass, color, size):
        self.pos = pos
        self.vel = vel
        self.mass = mass
        self.color = color

        self.size = size

class LinePlanet():
    def __init__(self, centerPos, vel, mass, mesh):
        self.pos = centerPos
        self.vel = vel
        self.mass = mass
        self.mesh = mesh

class Player(SmallBody):
    def __init__(self, pos, vel, thrust, size, mass):
        self.pos = pos
        self.vel = vel
        self.thrust = thrust
        self.size = size
        self.mass = mass

    def draw(self, app):
        drawCircle(*renderCoords(app, self.pos), self.size * app.scale, fill = 'blue')

player = Player([-30, 0, 0], [0, 0, 0], [0, 0], 30, 1)


# === PHYSICS MATHEMATICS ===

# Helper collection


def hypotenuse(a, b):
    return (a ** 2 + b ** 2) ** 0.5

def distance(x1, y1, x2, y2):
    return( (y2 - y1) ** 2 + (x2 - x1) ** 2 ) ** 0.5

# Player Physics
linearThreshold = 0.1
rotationalThreshold = 0.1
constantThrustDrag = 0.02
constantRollDrag = 0.04

def takePlayerPhysicsStep(app):
    fNetx, fNety = calcPlayerNetForce(app)
    # Acceleration, velocity, position
    ddx = fNetx / player.mass
    ddy = fNety / player.mass
    ddTheta = calcPlayerNetTorque(app) / player.mass

    player.vel[0] += ddx
    player.vel[1] += ddy
    player.vel[2] += ddTheta

    #wsnapVelocitiesToZero()
    
    player.pos[0] += player.vel[0]
    player.pos[1] += player.vel[1]
    player.pos[2] += player.vel[2]
    
def calcPlayerNetForce(app):
    fNetx, fNety = 0, 0 
    fNetx += player.thrust[0] * math.sin(math.radians(player.pos[2]))
    fNety += player.thrust[0] * math.cos(math.radians(player.pos[2]))

    dxPlanet = app.objectOnePos[0] - player.pos[0]
    dyPlanet = app.objectOnePos[1] - player.pos[1]

    bigG = 30
    fNetx += ( bigG * player.mass / (dxPlanet ** 2 + dyPlanet ** 2) ) * dxPlanet
    fNety += ( bigG * player.mass / (dxPlanet ** 2 + dyPlanet ** 2) ) * dyPlanet

    #fNetx -= player.vel[0] * constantThrustDrag
    #fNety -= player.vel[1] * constantThrustDrag
    return fNetx, fNety

def calcPlayerNetTorque(app):
    fNetTheta = 0
    fNetTheta += player.thrust[1]
    fNetTheta -= player.vel[2] * constantRollDrag
    return fNetTheta

def snapVelocitiesToZero():
    if player.thrust[0] == 0:
        if abs(player.vel[0]) < linearThreshold:
            player.vel[0] = 0
        if abs(player.vel[1]) < linearThreshold:
            player.vel[1] = 0
    if player.thrust[1] == 0:
        if abs(player.vel[2]) < rotationalThreshold:
            player.vel[2] = 0

# Movement Keys
def playerPressedKeyThrust(app, key): # Changes value based on the single key press input
    if key in {'w', 'a', 's', 'd'}:
        app.Thrusting = True
        player.thrust = [
            ( int(key == 'w') - int(key == 's') ) * app.playerThrustConstant,
            ( int(key == 'd') - int(key == 'a') ) * app.playerTwistConstant
    ]

def playerHeldKeyThrust(app, keyList): # Changes values based on being in the list of held keys
    if 'w' in keyList or 'a' in keyList or 's' in keyList or 'd' in keyList:
        app.Thrusting = True
        player.thrust = [
            ( int('w' in keyList) - int('s' in keyList) ) * app.playerThrustConstant,
            ( int('d' in keyList) - int('a' in keyList) ) * app.playerTwistConstant
    ]

def playerReleasedKeyThrust(app, key):
    app.Thrusting = False
    player.thrust = [0, 0]

# === EVENT HANDLING ===

# Stepping

def onStep(app):
    takePlayerPhysicsStep(app)
    setRenderOrigin(app) # I want it to center on any screen size, for now
    app.scale *= app.directionScaleChange

# Player Interaction

def onKeyPress(app, key):
    playerPressedKeyThrust(app, key)

def onKeyHold(app, key):
    playerHeldKeyThrust(app, key)
    if app.scale < 5 and 'up' in key:
        app.directionScaleChange = 1.1
    elif app.scale > 0.1 and 'down' in key:
        app.directionScaleChange = 0.9

def onKeyRelease(app, key):
    playerReleasedKeyThrust(app, key)
    app.directionScaleChange = 1

# === RENDERING ===

def setRenderOrigin(app, posX = 0.5, posY = 0.5):
    app.renderOrigin = (app.width * posX, app.height * posY)

def renderTranslate(x, y, cx, cy):
    return x - cx, y - cy

def renderRotate(x, y, theta):
    theta = math.radians(theta)
    rotatedX = math.cos(theta) * x - math.sin(theta) * y
    rotatedY = math.sin(theta) * x + math.cos(theta) * y
    return rotatedX, rotatedY

def renderCoords(app, posTuple): # The master renderer
    xReal, yReal = posTuple[0], posTuple[1]
    if len(posTuple) == 3: # I want it to accept both coord and coord + rotation
        thetaReal = posTuple[2]
    else:
        thetaReal = None

    xCam, yCam = player.pos[0], player.pos[1]
    thetaCam = player.pos[2]
    
    # Shift the coordinates in realspace to put the camera at origin
    tx, ty = renderTranslate(xReal, yReal, xCam, yCam)
    rx, ry = renderRotate(tx, ty, thetaCam)
    finalx, finaly = rx * app.scale, ry * app.scale
    
    # Shift to render scheme
    xRender, yRender = app.renderOrigin[0] + finalx, app.renderOrigin[1] - finaly
    return xRender, yRender
# === DRAWING ===

def redrawAll(app): 
    drawCircle(*renderCoords(app, app.objectOnePos), 400 * app.scale, fill = 'green')
    drawLineTopX, drawLineTopY = app.objectOnePos[0], app.objectOnePos[0] + 30
    drawLine(*renderCoords(app, app.objectOnePos), *renderCoords(app, (drawLineTopX, drawLineTopY)), lineWidth = 2 * app.scale, fill = 'black')

    drawPlayer(app)
    drawRenderOrigin(app)

    drawLabel(f"Thrust: {player.thrust}", 100, 30, align = 'left')
    xThrust = math.sin(math.radians(player.pos[2]))
    yThrust = math.cos(math.radians(player.pos[2]))
    drawLabel(f"Angle Components: {xThrust}, {yThrust}", 100, 110, align = 'left')

    drawLabel(f"Speed: {player.vel}", 100, 50, align = 'left')
    trueSpeed = hypotenuse(player.vel[0], player.vel[1])
    drawLabel(f"Absolute Speed:{trueSpeed}", 100, 70, align = 'left')

    drawLabel(f"Pos: {player.pos}", 100, 90, align = 'left')

    drawLabel(f"Scale: {app.scale}", 100, 130, align = 'left')

    

# === Early Stage CMU-Graphics Renderers

def drawRenderOrigin(app):
    drawCircle(*app.renderOrigin, 3 * app.scale, fill = 'black')

def drawPlayer(app):
    player.draw(app)

# === MAIN ===

def main():
    scale = 600
    runApp(width = 600, height = 600)

main()