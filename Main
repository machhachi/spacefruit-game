# Main.py

# Spacefruit the Game
# Main file
# By Alexander Werth
# Andrew ID: awerth2
# Recitation: U

# Cumulative Hours = about 51, but who's counting?

# <=> Credits, Disclaimers, and Inspiration <=>

# Explicit crediting: I did not create the line-segment intersection I used
# Find it here at https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/
# It serves in a raycasting algorithm, to check the collisions between generated rays and polygon segments in LinePlanet -> getExpandedCollisionData

# Thank you to Michael Taylor for the class, the OH, the time, the thought, and the conversation.
# As of 1am on 7/29/25, your original suggestion for raycast polygon collisions is fully implemented, much to my relief.
# This had better make it in the history books.

# <=> Cool Things that You should Look At <=>

# Check out my MyMath and Vector classes! It's made for some very elegant coding, especially the latter, though some early areas (gravity) predate use of vector methods.

# PLEASE be as impressed by LinePlanets as I am. The collision logic for them was astoundingly hard.
#   - Note that each time a Smallbody runs collision checking on a line planet, it passes in its own radius.
#   - That's because each Line Planet is prepared to generate a collision mesh LIVE, custom such that it'll interact with the centerpoint of the body calling upon it.
#   - The subsequent actual collision checking is fun too: it implements my built-by-hand(almost, see disclaimer) raycasting,
#       and even generates circular colliders at the vertices to handle corners.

# Scroll down to the Render class as well!
#   Rendering was essentially the first major tool I designed, and it now lets me navigate my simulation world like a dream:
#   - All 'world' coordinates are totally fixed,
#   - The player 'camera' can move, rotate, and zoom in/out at will,
#   - And, as mathematics intended, positive Y correlates to upwards on the screen.

# FadingScreentext objects and the Velocity indicator in Player both operate on some PID-inspired opacity changing, if that piques your interest.

# I've done an interesting dive into instancing objects within sets and then culling them!
#   The text classes served as a practice run for this,
#   And I'm broadening for the fruit handling.

# <=> Desires <=>

# Real current projects

# ACHIEVED GENERAL GRAVITY
# ACHIEVED LINE PLANETS
# ACHIEVED DIAGETIC LINE PLANET COLLISIONS
# ACHIEVED MOVING PLANET COLLISIONS
# ACHIEVED PARAMETERIZED ROTATION
# ACHIEVED PARAMETERIZED ORBITS
# ACHIEVED COMBINED ROTATION + ORBITS
# ACHIEVED NESTED ORBITS
# ACHIEVED LANDING MODE
# ACHIEVED DIAGETIC LANDING MODE ACTIVATION
# ACHEIVED TRANSPARENT SPRITES
# ACHIEVED VELOCITY INDICATOR
# ACHIEVED START + PAUSE MENUS
# ACHIEVED FRUIT SPAWNING
# ACHIEVED FRUIT PICKUP WITH INSTANCE CULLING
# ACHIEVED STABLE INTERVAL FRUIT SPAWNING

# Player ejecting fruit from inventory
# Score area that consumes and counts the scores of fruit

# Fields of investigation


# Drawing a lineplanet on top of a planet. I think we're ready.
#   Actually, we've been ready with static planets, but now, we can do it with rotation.
#   Make sure the sphere and line planets share a center, then, the rotation method should do the trick.


# === IMPORTS ===

from cmu_graphics import *
import math

# === CLASSES: FUNCTION LIBRARIES ===

class MyMath():
    def __init__(self):
        pass

    def sign(self, x):
        return 1 if x >= 0 else -1
    
    def hypotenuse(self, a, b):
        return (a ** 2 + b ** 2) ** 0.5
    
    def distance(self, x1, y1, x2, y2):
        return self.hypotenuse(x2 - x1, y2 - y1)
    
    def heronArea(self, a, b, c):
        s = (a + b + c) / 2
        return ( ( s * (s - a) * (s - b) * (s - c) ) ** 0.5 )
    
mymath = MyMath()

class Vector(): # A package of vector functions
    def __init__(self):
        pass

    def vectorize(self, line): # Line (coords) to vector
        return (line[1][0] - line[0][0], line[1][1] - line[0][1])

    def distance(self, v1, v2):
        dx = v2[0] - v1[0]
        dy = v2[1] - v1[1]
        return mymath.hypotenuse(dx, dy)
    
    def len(self, v):
        return mymath.hypotenuse(v[0], v[1])
    
    def add(self, v1, v2):
        return (v1[0] + v2[0], v1[1] + v2[1])
    
    def subtract(self, v1, v2):
        return (v1[0] - v2[0], v1[1] - v2[1])
    
    def scale(self, v, k):
        return (v[0] * k, v[1] * k)
    
    def unit(self, v): # With non-div0 insurance ( I can't believe that didn't come up until now! )
        return (0, 0) if self.len(v) == 0 else ( v[0] / self.len(v), v[1] / self.len(v) )
    
    def dot(self, v1, v2):
        return v1[0] * v2[0] + v1[1] * v2[1] # startlingly simple
    
    def cw(self, v):
        return (v[1], -v[0])
    
    def ccw(self, v):
        return (-v[1], v[0])
    
    def heronAreaByPoints(self, pointP, pointQ, pointR):
        lineA, lineB, lineC = vector.distance(pointP, pointQ), vector.distance(pointQ, pointR), vector.distance(pointR, pointP)
        return mymath.heronArea(lineA, lineB, lineC)
    
    def add2to3(self, v3, v2):
        return(v3[0] + v2[0], v3[1] + v2[1], v3[2])
    
    def rotate(self, v, theta):
            inputX = v[0]
            inputY = v[1]
            theta = math.radians(theta)
            rotatedX = math.cos(theta) * inputX - math.sin(theta) * inputY
            rotatedY = math.sin(theta) * inputX + math.cos(theta) * inputY
            return (rotatedX, rotatedY)
    
vector = Vector()

class Motion(): # Specific handlers for my motion (mostly conversion from tuples to lists)
    def __init__(self):
        pass

    # Mutating component addition
    def plusEq(self, thing1, thing2, ignoreThirdComponent = False):
        # componentwise list modification. Designed to function whether or not second list / tuple has a third component (but always expects first to have one)
        thing1[0] += thing2[0]
        thing1[1] += thing2[1]
        if not ignoreThirdComponent and len(thing2) == 3:
            thing1[2] += thing2[2]

    # Non-mutating component addition
    def getSum(self, thing1, thing2, ignoreThirdComponent = False):
        # Componentwise list modification
        compX = thing1[0] + thing2[0]
        compY = thing1[1] + thing2[1]
        compR = thing1[2] + thing2[2] if ( not ignoreThirdComponent and len(thing2) == 3 ) else thing1[2]
        return [compX, compY, compR]

    def invert(self, thing1):
        return [comp * -1 for comp in thing1]

    def getPosAboutCenter(self, centerPos, radialDist, theta):
        radialPosVector = (radialDist, 0)
        return vector.add(centerPos, vector.rotate(radialPosVector, theta))
    
motion = Motion()

# === CLASSES: SIMULATION SUPPORT ===

class FadingScreentext():
    def __init__(self, app, contents:str, pos, size:int, 
                 color = 'white', initiallyOn:bool = True, 
                 align:str = 'center', 
                 opacityDropRate:float = 0.07, opacityGrowthRate:float = 0.1):
        self.contents = contents
        self.x, self.y = pos
        self.size = size
        self.fill = color
        self.align = align
        
        self.opacity = 100 if initiallyOn else 0
        self.desiredOpacity = 100 if initiallyOn else 0
        self.opacityDropRate = opacityDropRate
        self.opacityGrowthRate = opacityGrowthRate

    def turnOn(self):
        self.desiredOpacity = 100

    def turnOff(self):
        self.desiredOpacity = 0

    def step(self):
        deltaOpacity = self.desiredOpacity - self.opacity
        percentChangeRate = self.opacityGrowthRate if deltaOpacity > 0 else self.opacityDropRate
        # Our minimum viable opacity shift is the one, for one percentage point. If the change is less than that, it fully snaps over.
        opacityShift = deltaOpacity * percentChangeRate if abs(deltaOpacity) > 1 else deltaOpacity
        self.opacity += opacityShift

    def draw(self, app):
        drawLabel(self.contents, self.x, self.y, size = self.size, fill = self.fill, opacity = self.opacity, align = self.align)

class Screenhandler():
    def __init__(self, app):
        print("app width is", app.width)
        self.width = 1600
        self.height = 1200
        self.startTexts = {
            # Top
            FadingScreentext(app, 'Welcome to Spacefruit!', (self.width // 2, 160), 60, 'orchid', False, 'center', 0.01),
            FadingScreentext(app, 'Enjoy the space.', (self.width // 2, 220), 30, 'mediumOrchid', False, 'center', 0.04),
            FadingScreentext(app, 'And maybe, the fruit.', (self.width // 2, 260), 20, 'mediumPurple', False, 'center', 0.04),
            FadingScreentext(app, 'Alex Werth, 15-112 N25', (self.width // 2, 320), 30, 'mediumSlateBlue', False, 'center', 0.04),

            # Left block
            FadingScreentext(app, 'Controls:', (50, 400), 40, 'orchid', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[W] [S]', (50, 450), 30, 'gold', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'for upwards and downwards thrust', (150, 450), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[A] [D]', (50, 500), 30, 'gold', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'for spinning left and right', (150, 500), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[Up] [Down]', (50, 550), 30, 'gold', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'for zooming in and out', (230, 550), 30, 'lavender', False, 'left', 0.05, 0.03),

            FadingScreentext(app, '[Enter]', (50, 650), 30, 'orchid', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to exit this screen and begin!', (150, 650), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[p]', (50, 700), 30, 'mediumOrchid', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to pause during the game', (90, 700), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[f]', (50, 750), 30, 'mediumPurple', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to launch a stored fruit', (90, 750), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[r]', (50, 800), 30, 'mediumSlateBlue', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to teleport home', (90, 800), 30, 'lavender', False, 'left', 0.05, 0.03),

            # Right block
            FadingScreentext(app, 'Guide:', (1550, 400), 40, 'gold', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'The purple arrows indicate gravitational bodies.', (1550, 450), 30, 'orchid', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'The gold arrow shows your velocity.', (1550, 500), 30, 'gold', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'Hit planets to collide with them,', (1550, 550), 30, 'lavender', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'and hit fruits to collect them.', (1550, 600), 30, 'lavender', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'Bring fruit to the bucket just underneath you!', (1550, 650), 30, 'lavender', False, 'right', 0.05, 0.03),

            FadingScreentext(app, 'Zoom out to, generally, run more smoothly.', (1550, 690), 20, 'mediumOrchid', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'Pardon the jitters of your thrust sprites.', (1550, 720), 20, 'mediumPurple', False, 'right', 0.05, 0.03),
            FadingScreentext(app, "The planet sprites behave weirdly, I fear.", (1550, 750), 20, 'mediumSlateBlue', False, 'right', 0.05, 0.03)
        }

        self.pauseTexts = {
            FadingScreentext(app, 'PAUSED', [50, 200], 80, 'lavender', False, 'left'),

            # Left block
            FadingScreentext(app, 'Controls:', (50, 400), 40, 'orchid', False, 'left'),
            FadingScreentext(app, '[W] [S]', (50, 450), 30, 'gold', False, 'left'),
            FadingScreentext(app, 'for upwards and downwards thrust', (150, 450), 30, 'lavender', False, 'left'),
            FadingScreentext(app, '[A] [D]', (50, 500), 30, 'gold', False, 'left'),
            FadingScreentext(app, 'for spinning left and right', (150, 500), 30, 'lavender', False, 'left'),
            FadingScreentext(app, '[Up] [Down]', (50, 550), 30, 'gold', False, 'left'),
            FadingScreentext(app, 'for zooming in and out', (230, 550), 30, 'lavender', False, 'left'),

            FadingScreentext(app, '[p]', (50, 650), 30, 'mediumPurple', False, 'left'),
            FadingScreentext(app, 'to pause during the game', (90, 650), 30, 'lavender', False, 'left'),
            FadingScreentext(app, '[f]', (50, 700), 30, 'mediumPurple', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to launch any stored fruit', (90, 700), 30, 'lavender', False, 'left', 0.05, 0.03),
            FadingScreentext(app, '[r]', (50, 750), 30, 'mediumSlateBlue', False, 'left', 0.05, 0.03),
            FadingScreentext(app, 'to teleport home', (90, 750), 30, 'lavender', False, 'left', 0.05, 0.03),

            # New Right Score Block
            FadingScreentext(app, 'Score:', (1550, 400), 40, 'gold', False, 'right', 0.05, 0.03),
            FadingScreentext(app, 'Approach the Lazula Vine bucket to see your score.', (1550, 450), 30, 'lavender', False, 'right', 0.05, 0.03),
        }

    def drawPaused(self, app):
        drawRect(0, 0, app.width, app.height, fill = 'black', opacity = 50)
            
    def drawStart(self, app):
        pass

    def draw(self, app):
        if app.gameStatus == 'start':
            self.drawStart(app)
        elif app.gameStatus == 'paused':
            self.drawPaused(app)

        for text in self.startTexts | self.pauseTexts:
            text.draw(app)

    # Starting methods
    def setStart(self, app):
        for text in self.startTexts:
            text.turnOn()
        for text in self.pauseTexts:
            text.turnOff()
        app.gameStatus = 'start'
    
    def setGame(self, app):
        for text in self.startTexts:
            text.turnOff()
        for text in self.pauseTexts:
            text.turnOff()
        app.gameStatus = 'game'

    def setPause(self, app):
        for text in self.pauseTexts:
            text.turnOn()
        app.gameStatus = 'paused'
        
    # Step
    def step(self):
        # Step normally, allowing text to transition among opacity
        for text in self.startTexts | self.pauseTexts:
            text.step()

        # Cull start text, it is never intended to reappear
        textToRemove = set()
        for text in self.startTexts:
            if text.opacity == 0 and text.desiredOpacity == 0:
                textToRemove.add(text)
        
        # Not allowed to modify length of set during iteration, so we hand off to a kill buffer that then wipes it out for us
        for killText in textToRemove:
            self.startTexts.remove(killText)
        textToRemove.clear()

screenHandler = Screenhandler(app)

# === CLASSES: DEBUG DRAWN OBJECTS ===

# A drawn object
class Helperball():
    Instances = set()
    def __init__(self, centerPos, size, color = 'black'):
        self.centerPos = centerPos
        self.size = size
        self.color = color

        Helperball.Instances.add(self)
    
    def draw(self, app):
        drawCircle(*render.getCoords(self.centerPos), render.getScale(self.size), fill = self.color)

class Helperline():
    Instances = set()
    def __init__(self, startPos, endPos, thickness, color = 'black'):
        self.startPos = startPos
        self.endPos = endPos
        self.color = color
        self.thickness = thickness

        Helperline.Instances.add(self)

    def setPos(self, startPos, endPos):
        self.startPos = startPos
        self.endPos = endPos
    
    def draw(self, app):
        drawLine(*render.getCoords(self.startPos), *render.getCoords(self.endPos), lineWidth = render.getScale(self.thickness), fill = self.color)

# === CLASSES: GAME OBJECTS ===

# SmallBodies: A small object that collides with planets
class SmallBody():
    Instances = set()

    def __init__(self, pos, vel, size, mass):
        self.pos = pos
        self.vel = vel
        self.size = size
        self.mass = mass

        SmallBody.Instances.add(self)

        self.constants = {
            'minimumLinearSpeed': 0,
            'minimumRotationalSpeed': 0,
            'constantThrustDrag': 0,
            'constantRollDrag': 0
        }

        self.collisionConstants = {
            'elasticity':0.5,
            'friction':0.7
        }

    # Physics 
    def takePhysicsStep(self, app):
        # Force
        fNetx, fNety = self.calcNetForce(app)
        fNetTheta = self.calcNetTorque()

        # Acceleration, velocity, position
        ddx = fNetx / self.mass
        ddy = fNety / self.mass
        ddTheta = fNetTheta / self.mass

        self.vel[0] += ddx
        self.vel[1] += ddy
        self.vel[2] += ddTheta

        self.applyDrag()
        self.snapVelocitiesToZero()
        
        self.pos[0] += self.vel[0]
        self.pos[1] += self.vel[1]
        self.pos[2] += self.vel[2]

    def calcNetForce(self, app):
        fNetx, fNety = 0, 0

        fGx, fGy = self.getAllPlanetGravity(app)

        fNetx += fGx
        fNety += fGy
        return fNetx, fNety

    def getAllPlanetGravity(self, app):
        if isinstance(self, Player):
            player.gravitationalPulls = set()

        fGx, fGy = 0, 0
        for thisPlanet in Planet.Instances:
            # Get distance vector to planet
            dxPlanet, dyPlanet = thisPlanet.pos[0] - self.pos[0], thisPlanet.pos[1] - self.pos[1]
            # Crunch newtonian gravity: gmM / r^2
            if dxPlanet == 0 and dyPlanet == 0:
                continue
            fGThisPlanet = ( app.bigG * self.mass * thisPlanet.mass ) / (dxPlanet ** 2 + dyPlanet ** 2)
            
            if isinstance(self, Player):
                gravityInfo = (dxPlanet, dyPlanet, fGThisPlanet)
                player.gravitationalPulls.add(gravityInfo)
    
            xHat, yHat = vector.unit((dxPlanet, dyPlanet))
            fGx += fGThisPlanet * xHat
            fGy += fGThisPlanet * yHat
        return fGx, fGy

    def calcNetTorque(self): # Placeholder for player
        return 0

    def applyDrag(self):
        self.vel[0] -= self.vel[0] * self.constants['constantThrustDrag'] / self.mass
        self.vel[1] -= self.vel[1] * self.constants['constantThrustDrag'] / self.mass
        self.vel[2] -= self.vel[2] * self.constants['constantRollDrag'] / self.mass

    def snapVelocitiesToZero(self):
        if abs(self.vel[0]) < self.constants['minimumLinearSpeed']:
            self.vel[0] = 0
        if abs(self.vel[1]) < self.constants['minimumLinearSpeed']:
            self.vel[1] = 0
        if abs(self.vel[2]) < self.constants['minimumRotationalSpeed']:
            self.vel[2] = 0

    # Planet Collision
    def collide(self):
        self.setPlayerColliding(False)
        self.collideWithSpheres()
        self.collideWithLines()
        self.collideWithBlackHoles()

    def collideWithSpheres(self):      
        for thisPlanet in SpherePlanet.Instances:
            # Test if we are within the collision circle, thus, colliding with the body
            if vector.distance(self.pos, thisPlanet.pos) <= self.size + thisPlanet.size:
                normal = thisPlanet.getNormalVectorTo(self.pos) # unit normal vector
                depth = vector.distance(self.pos, thisPlanet.pos) - (self.size + thisPlanet.size)

                self.setPlayerColliding(True)
                self.setPlayerLanding(thisPlanet, normal)
                self.evaluatePlanetCollision(thisPlanet, normal, depth)
                self.moveWithRotatingPlanet(thisPlanet)
                
    def collideWithLines(self):
        for thisPlanet in LinePlanet.Instances:
            # Don't bother calculating unless we're in the relevant range to begin
            if vector.distance(self.pos, thisPlanet.pos) <= thisPlanet.getCollisionCheckRadius():
                # Use dedicated lineplanet collision method, which takes a size, as to generate a specific collision mesh that interacts with this smallbody's radius
                collisionResult = thisPlanet.getExpandedCollisionData(self.pos, self.size)
                if collisionResult != False:
                    normal, trueDepth = collisionResult

                    self.setPlayerColliding(True)
                    self.setPlayerLanding(thisPlanet, normal)
                    self.evaluatePlanetCollision(thisPlanet, normal, trueDepth)
                    self.moveWithRotatingPlanet(thisPlanet)

    def moveWithRotatingPlanet(self, collidingPlanet):
        assert(isinstance(collidingPlanet, Planet))
        
        planetPos, planetVel = collidingPlanet.getPosVelData()  
        if planetVel[2] != 0: # If planet is rotating!!!:
            # Just rotate along the position vector relative to planet center
            smallBodyRelPos = vector.subtract(self.pos, planetPos)
            rotatedRelPos = vector.rotate(smallBodyRelPos, planetVel[2])
            
            linearMovementMade = vector.subtract(rotatedRelPos, smallBodyRelPos) # The distance to travel
            rotationChanged = -planetVel[2] # The body should corotate with a rotating body it sits on
            dPosition = list(linearMovementMade) + [rotationChanged] # Format to 3-len list

            motion.plusEq(self.pos, dPosition) # Single mutation should do it

    def evaluatePlanetCollision(self, collidingPlanet, normal, depth):
        assert(isinstance(collidingPlanet, Planet))

        def stripPlanetMotion(velocity, thisPlanet):
            planetPos, planetVel = thisPlanet.getPosVelData()
            return motion.getSum(velocity, motion.invert(planetVel))

        def injectPlanetMotion(velocity, thisPlanet):
            planetPos, planetVel = thisPlanet.getPosVelData()
            return motion.getSum(velocity, planetVel)
        
        relativeVelocity = stripPlanetMotion(self.vel, collidingPlanet)

        normalX, normalY = normal[0], normal[1]

        vRadial = vector.dot(relativeVelocity, normal) # magnitude velocity in direction of planet center
        vXRadial, vYRadial = normalX * vRadial, normalY * vRadial # components 
        
        # Trigger if we simply have hit the planet too fast (to not engage landing)
        exceededAdhesionThreshold = abs(vRadial) > player.landingConstants['maxAdhesionThreshold']

        # Evaluate collision if we're moving inwards towards planet

        if vector.dot(normal, (vXRadial, vYRadial)) < 0: # Negative -> misaligned -> moving inwards towards planet
            # (Note: if you were to check position interiority and not velocity, then you might repeat this collision)
            # (That would be rubber-banding, where you get insane collisions because one phys step isn't enough to un-collide you)
            # (This way, any collision will only have 1 velocity change before the object stops going inwards)

            # Position adjustment
            #   Depth, or Altitude when positive, (inward-surface-to-surface dist), is negative since we are within collision bounds
            #   So subtract it out of position to push smallbody to the exact bound
            self.pos[0] -= depth * normalX
            self.pos[1] -= depth * normalY

            # Velocity adjustment
            #   First, extract radial and tangential velocity
            vXTangential = relativeVelocity[0] - vXRadial
            vYTangential = relativeVelocity[1] - vYRadial

            # PLAYER INJECTION

            # Simply nope it if we have hit too hard
            if exceededAdhesionThreshold:
                player.landing = False

            if isinstance(self, Player) and player.landing: # Modify characteristics to landing characteristics
                elasticity = player.landingConstants['elasticity']
                friction = player.landingConstants['friction']
            else:
                elasticity = self.collisionConstants['elasticity']
                friction = self.collisionConstants['friction']

            # Radial component: "bounce" speed. Output should be 0x original (inelastic) up to -1x(elastic)
            newVXRadial = -vXRadial * elasticity
            newVYRadial = -vYRadial * elasticity

            # Tangential component: "skid" speed. Multiply by some decreasing fraction, and convert some to rolling.
            newVXTangential = vXTangential * (1 - friction)
            newVYTangential = vYTangential * (1 - friction)

            if not (isinstance(self, Player) and player.landing):

                # Roll component: rolling. Whatever was lost in tangential, we assume it goes about fully into rolling.
                #   To get the direction: we need to know if we're moving CW or CCW about the planet 
                #   If you rotate the normal vector (points outwards) 90 degrees CW, that now points in the CW-about-planet direction
                #   And we can use dot product to see if we're aligned or unaligned with that

                # Vector transformation for rotating CW 90 degrees
                surfaceTangentX, surfaceTangentY = normalY, -normalX
                rollVelocity = vector.dot((vXTangential, vYTangential), (surfaceTangentX, surfaceTangentY)) * friction

                # Convert linear to angular by diving by radius
                rollConversionFactor = 10 / self.size # I feel like the 10 should be 30 for step count, but that creates too dramatic of an effect
                
                # Decreasing old angular velocity is a crack solution to the rolling-amplification issue I had a bit ago
                oldRollCarryover = relativeVelocity[2] * 0.95
                newVTheta = oldRollCarryover + rollVelocity * rollConversionFactor
            
            else:
                newVTheta = -collidingPlanet.vel[2]

            # Recombine 

            recombinedVel = [
                newVXRadial + newVXTangential,
                newVYRadial + newVYTangential,
                newVTheta
            ]

            self.vel = injectPlanetMotion(recombinedVel, collidingPlanet)
    
    def collideWithBlackHoles(self):
        for thisHole in BlackHole.Instances:
            thisHole.checkAndTeleport(self) # Internally handled
            
    # Player Landing
    def setPlayerLanding(self, collidingPlanet, normal):
        # Only eval for player!!!
        if isinstance(self, Player):
            if player.colliding:
                # I've had to play with some things
                
                # Normal angle appears to be flipped 180 from what I want, not sure why, so I added the negative.
                normalAngle = (-math.degrees(math.atan2(normal[1], normal[0])) ) % 360

                # I add a quarter turn to the player because their default angle is, I suppose, 0 in positive x, and I'd like this to represent
                #   angle from their vertical (to make them upright)
                playerAngle = (player.pos[2] - 90) % 360
                
                isLanding = abs(normalAngle - playerAngle) <= player.landingConstants['fieldOfLandingAngle']
                player.landing = isLanding
            else:
                player.landing = False

    def setPlayerColliding(self, value:bool):
        if isinstance(self, Player):
            player.colliding = value
            
    # Rendering
    def draw(self, app):
        drawCircle(*render.getCoords(self.pos), render.getScale(self.size), fill = 'black')
        drawStar(*render.getCoords(self.pos), render.getScale(self.size), 5, fill = 'white', rotateAngle = render.getAngle(self.pos[2]))

    # Step
    def step(self, app):
        self.collide()
        self.takePhysicsStep(app)

class Player(SmallBody):

    # === # === # === # === #
    # PLAYER SPECIFIC OPERATIONS
    # === # === # === # === #

    def __init__(self, pos, vel, size, mass):
        super().__init__(pos, vel, size, mass)
        self.thrust = [0, 0]

        self.boostMeter = 100
        self.boostMax = 100
        self.boostRefillRate = 1

        self.colliding = False
        self.landing = False
        
        self.ticksPerSprite = 2 # Self explanatory. 1 makes the fire sprite change each frame, increase for less frequency.
        self.thrustSpriteIndex = 0

        self.thrustConstants = {
            'thrustForce': 30,
            'rollForce': 5,
            'boostMult': 2
        }

        self.constants = {
            'minimumLinearSpeed': 0.001,
            'minimumRotationalSpeed': 0.005,
            'constantThrustDrag': 0.02,
            'constantRollDrag': 0.1
        }

        self.landingConstants = {
            'elasticity': 0,
            'friction': 1,
            'fieldOfLandingAngle': 30, # The angle range, centered around the bottom of the player. in which landing is automatically activated
            'maxAdhesionThreshold': 10 # Speed threshold, relative to planet radial line, over which an attempt to land is just cancelled
        }

        self.defineSpecialtyTrackingVariables()
        self.initializeFruitBusiness()
  
    # Key inputs
    def thrustKeysPressed(self, key):
        if key in {'w', 'a', 's', 'd'}:
            player.thrust = [
                ( int(key == 'w') - int(key == 's') ) * self.thrustConstants['thrustForce'],
                ( int(key == 'd') - int(key == 'a') ) * self.thrustConstants['rollForce']
            ]

    def thrustKeysHeld(self, keyList):
        setKeys = set(keyList)
        if setKeys.intersection({'w', 'a', 's', 'd'}) != set(): # Non-empty intersection, so at least 1 is held
            player.thrust = [
                ( int('w' in setKeys) - int('s' in setKeys) ) * self.thrustConstants['thrustForce'],
                ( int('d' in setKeys) - int('a' in setKeys) ) * self.thrustConstants['rollForce']
            ]
            player.thrustSpriteIndex = (player.thrustSpriteIndex + 1) % (4 * self.ticksPerSprite)
            player.landing = False
    
    def thrustKeysReleased(self):
        player.thrust = [0, 0]

    def generalKeysPressed(self, app, key):
        if key == 'r':
            self.returnToLazula()
        elif key == 'f':
            playerCannon.launchOneFruit(app) # I love that I have a method named this
    
    def generalKeysHeld(self, app, keyList):
        render.scaleChangeDirection = int('up' in keyList) - int('down' in keyList)

    def generalKeysReleased(self, app, key):
        render.scaleChangeDirection = 0

    # Boost thrust
    def getBoost(self):
        return self.boostMeter

    def stepBoost(self):
        if self.thrust[0] != 0 and self.boostMeter > 0:
            boostThrust = self.thrustConstants['thrustForce'] * self.thrustConstants['boostMult'] 
            self.thrust[0] = mymath.sign(self.thrust[0]) * boostThrust
            self.boostMeter -= 1
        elif self.thrust[0] == 0 and self.boostMeter < self.boostMax:
            self.boostMeter += self.boostRefillRate
        #print(self.boostMeter)

    # Modified physics methods
    def calcNetForce(self, app): # Includes player thrust
        # Force
        fNetx, fNety = 0, 0 

        # Player input
        fNetx += self.thrust[0] * math.sin(math.radians(self.pos[2]))
        fNety += self.thrust[0] * math.cos(math.radians(self.pos[2]))

        # Gravity
        # Gravity method is the same for small bodies as is for player
        fGx, fGy = self.getAllPlanetGravity(app)
        fNetx += fGx
        fNety += fGy

        return fNetx, fNety

    def calcNetTorque(self): # Includes player thrust
        fNetTheta = 0
        fNetTheta += self.thrust[1]
        return fNetTheta
    
    def snapVelocitiesToZero(self): # Only invokes if player not thrusting
        if self.thrust[0] == 0:
            if abs(self.vel[0]) < self.constants['minimumLinearSpeed']:
                self.vel[0] = 0
            if abs(self.vel[1]) < self.constants['minimumLinearSpeed']:
                self.vel[1] = 0
        if self.thrust[1] == 0:
            if abs(self.vel[2]) < self.constants['minimumRotationalSpeed']:
                self.vel[2] = 0

    # Stepping
    def step(self, app):
        self.stepBoost()
        self.collide()
        self.checkFruitCollisions(app)
        self.takePhysicsStep(app)

        self.stepSpecialtyTrackingVariables()
    
    # Rendering
    def getFlamesThatShouldBeDrawn(self):
        # Returns one list based on whether or not to display the rocket flames
        result = []
        if self.thrust[1] < 0: # If turning left, display right thruster
            result.append('right')
        if self.thrust[1] > 0: # If turning right, left thruster
            result.append('left')
        if self.thrust[0] != 0: # If moving forward, whatever, run the main
            result.append('main')
        return result

    def draw(self, app):
        mainSprite = "assets/player/player_base.png"

        rawWidth, rawHeight = getImageSize(mainSprite) # ought to be 500 x 500
        playerScaleFactor = self.size * 0.0042 # PERFECT NUMBER
        realWidth, realHeight = render.getScale(rawWidth * playerScaleFactor), render.getScale(rawHeight * playerScaleFactor)

        # Drawing possible thrust directions
        if player.thrust != [0, 0]: # Cull for processing speed
            for direction in self.getFlamesThatShouldBeDrawn(): # One string for each thruster
                thisSprite = self.thrustSpriteIndex // self.ticksPerSprite + 1
                flameSprite = f"assets/player/player_flame_{direction}_{thisSprite}.png"
                drawImage(flameSprite,
                        *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                        width = realWidth * 2, height = realHeight * 2, align = 'center')
                
        # Drawing player

        drawImage(mainSprite, 
                  *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                  width = realWidth, height = realHeight, align = 'center')
        
        # Drawing two types of landing legs
        
        landingCondition = 'open' if self.landing else 'closed'
        landingSprite = f"assets/player/player_landing_{landingCondition}.png"

        drawImage(landingSprite, 
                  *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                  width = realWidth, height = realHeight, align = 'center')
        
        # Other bonuses
        self.drawSpecialty()
    
    # === # === # === # === #
    # PLAYER WORLD INTERFACE METHODS
    # === # === # === # === #

    # Emergency home teleport
    def returnToLazula(self):
        # We really want the velocity to be instantly set to something normal
        self.vel = LazulaVine.vel.copy()
        desiredPos = motion.getPosAboutCenter(LazulaVine.pos, LazulaVine.size + self.size, LazulaVine.pos[2] + 90)
        self.pos = [desiredPos[0], desiredPos[1], -LazulaVine.pos[2]]

    # Fruit collection
    def initializeFruitBusiness(self):
        self.fruitInventory = []

    # Fruit culling
    @staticmethod
    def startFruitCullList(app):
        app.fruitsToCull = set()
    
    @staticmethod
    def appendFruitCullList(app, spawnerInstance, fruitInstance):
        fruitData = (spawnerInstance, fruitInstance)
        app.fruitsToCull.add(fruitData)
    
    @staticmethod
    def emptyFruitCullList(app):
        for fruitToDieData in app.fruitsToCull:
            fruitToDieData[0].spawnedFruit.remove(fruitToDieData[1]) # Storage from the spawner
            SmallBody.Instances.remove(fruitToDieData[1]) # Got a smallbody instance as a result of superclassing
            if app.debugPrint:
                print("Culled one fruit from all physical lists")
        app.fruitsToCull.clear()

    def checkFruitCollisions(self, app):
        for spawner in FruitSpawner.Instances | PlayerFruitSpawner.Instances: # Fruit stored in sets belonging to the spawners
            for possibleFruit in spawner.spawnedFruit: 
                if vector.distance(player.pos, possibleFruit.pos) <= player.size + possibleFruit.size:
                    # Pass both fruit and spawner to clearign function, as there's no global fruit location
                    Player.appendFruitCullList(app, spawner, possibleFruit)

                    self.fruitInventory.append(possibleFruit.getType())
                    if app.debugPrint:
                        print("Player inventory is now:", self.fruitInventory)
        
        
    # === # === # === # === #
    # PLAYER VISUAL INTERFACE METHODS
    # === # === # === # === #

    # Bonus draw behaviors
    def defineSpecialtyTrackingVariables(self):
        # Sprite index
        self.masterTickIndex = 0

        # Velocity indicator
        self.prevVel = 0
        self.velOpacity = 0
        self.targetVelOpacity = 0

        # Gravity Collection
        self.gravitationalPulls = set()

    def stepSpecialtyTrackingVariables(self):
        # VELOCITY INDICATOR

        # PID-style change handling
        deltaOpacity = self.targetVelOpacity - self.velOpacity
        # The max switches between a proportional chunk of the difference (Each tick, it goes 50% of the way)
        #   and, when that gets too infinitesmally small, snaps to the exact difference

        # We want it to appear faster than it disappears
        percentChange = 0.1 if deltaOpacity > 0 else 0.03 

        # Our minimum viable opacity shift is the one, for one percentage point. If the change is less than that, it fully snaps over.
        opacityShift = deltaOpacity * percentChange if abs(deltaOpacity) > 1 else deltaOpacity
        self.velOpacity += opacityShift
        self.velOpacity = min(100, max(self.velOpacity, 0))

    def drawSpecialty(self):
        self.drawVelocityIndicator()
        self.drawGravityIndicators()

    # Line + arrow indicators
    def drawVelocityIndicator(self):
        # Draw a line
        velocityLineStartRadius = self.size * 1.5
        velocityLineLengthMultiplier = 10

        # CUSTOM COLOR
        color = gradient(rgb(217, 184, 20), rgb(255, 166, 0), rgb(255, 111, 0), start='center')
        # Looks a bit like the golden spaceship cover

        # VARIABLE OPACITY
        
        # It will have variable opacity, made more opaque by events occuring and then fading with time
        opacityWeightSpeed = 2 # The line will always be a little opaque if it moves
        opacityWeightAcceleration = 75 # The line will jump back if speed ever dramatically changes
        opacityWeightThrust = 100 # The line will jump to nearly full opacity if we are actively thrusting

        # Calculate speed
        currentSpeed = vector.len(player.vel)

        # Calculate (and prepare) change in speed
        changeInSpeed = currentSpeed - self.prevVel
        self.prevVel = currentSpeed

        # Get thrusting status
        playerThrusting = int(player.thrust[0] != 0)

        # Sum weights together
        weightedDesiredOpacity = (currentSpeed * opacityWeightSpeed + 
                                  changeInSpeed * opacityWeightAcceleration + 
                                  playerThrusting * opacityWeightThrust)
        
        # Convert to a usable opacity 0-100
        self.targetVelOpacity = int(min(weightedDesiredOpacity, 100))
        
        # SPECIAL COORDNIATES

        # Offset the line start from the player by their size
        velocityLineStart = render.getCoords( 
            vector.add(
                player.pos, 
                vector.scale( vector.unit(player.vel), velocityLineStartRadius)
            )
        )
        # Extend it outwards from the *starting point. Must redo the calculations, as they've already been passed through render.
        velocityLineEnd = render.getCoords(
            vector.add(
                vector.add(player.pos, vector.scale(vector.unit(player.vel), velocityLineStartRadius) ),
                vector.scale(player.vel, velocityLineLengthMultiplier)
            )
        )
        drawLine(
            *velocityLineStart, *velocityLineEnd,
            lineWidth = render.getScale(4),
            fill = color, arrowEnd = True,
            opacity = self.velOpacity
        )

    def drawGravityIndicators(self):
        planetLineStartRadius = self.size * 2
        planetLineLengthMultiplier = 8
        planetLineOpacityMultiplier = 10

        # Custom color
        color = gradient('royalBlue', 'darkOrchid', start='center')

        # GET GRAVITY FROM CUSTOM LIST CREATED WITHIN SMALLBODY GRAVITATION METHOD
        for gravityInstance in player.gravitationalPulls: 
            planetVector = gravityInstance[:2]
            planetDirection = vector.unit(planetVector)
            #planetDistance = vector.len(planetVector)
            gravityForce = gravityInstance[2]
            
            gravityLineStart = render.getCoords(
                vector.add(
                    player.pos, 
                    vector.scale(planetDirection, planetLineStartRadius)
                )
            )
            # Extend it outwards from the *starting point. Must redo the calculations, as they've already been passed through render.
            gravityLineEnd = render.getCoords(
                vector.add(
                    vector.add(player.pos, vector.scale(planetDirection, planetLineStartRadius) ),
                    vector.scale(planetDirection, gravityForce * planetLineLengthMultiplier)
                )
            )

            opacity = int(min(100, max(25, gravityForce * planetLineOpacityMultiplier)))

            drawLine(
                *gravityLineStart, *gravityLineEnd,
                lineWidth = render.getScale(4),
                fill = color, arrowEnd = True,
                opacity = opacity
            )

    # === # === # === # === #
    # BACKGROUND VISUALIZATION
    # === # === # === # === #

    def setPos(self, pos): # Helpful method so that background is moved with the player properly
        self.pos = pos
    
    def drawBackground(self, app):
        parallax = 0.25
        imagePath = 'assets/visuals/Background.jpeg'
        imageWidth, imageHeight = getImageSize(imagePath)

        # Last multiplication is to make it not be smaller than the max screen
        customScale = (((render.scale - 1) * parallax) + 1) * 2

        drawImage(imagePath, app.width / 2, app.height / 2, align = 'center',
                  width = imageWidth * customScale, height = imageHeight * customScale,
                  rotateAngle = -player.pos[2] )

class Fruit(SmallBody):
    # Interestingly, (I've decided that) fruit HAS no global instance set
    # Fruit is a class whose instances I want more control over deleting and creating
    # So they will all remain disparately bound up in the sets of their respective permanent spawners

    typeDict = {
            'grape':{
                'Name': 'Lazulan Grapes',
                'Size': 25,
                'Mass': 25,
                'Score': 1
            },
            'apple':{
                'Name':'Forgotten Honeycrisp',
                'Size':35,
                'Mass':40,
                'Score':12
            },
            'raspberry':{
                'Name':'Ruby Raspberry',
                'Size':15,
                'Mass':15,
                'Score':10
            },
            'blackberry':{
                'Name':'Sapphire Blackberry',
                'Size':15,
                'Mass':15,
                'Score':10
            },
            'peach':{
                'Name':'Cloudcover Peach',
                'Size':30,
                'Mass':15,
                'Score':25,
            },
            'fig':{
                'Name':'Solemn Heart Fig',
                'Size':20,
                'Mass':60,
                'Score':30,
            }
        }

    def __init__(self, pos, vel, type):

        self.type = type
        self.thisFruitInfo = self.typeDict[self.type]
        size = self.thisFruitInfo['Size']
        mass = self.thisFruitInfo['Mass']

        if len(pos) < 3:
            pos += [0]
        
        super().__init__(pos, vel, size, mass)    

        self.name = self.thisFruitInfo['Name']
    
    def getName(self):
        return self.name

    def getType(self):
        return self.type

    def draw(self, app):
        sprite = f"assets/fruit/{self.type}.png"
        rawWidth, rawHeight = getImageSize(sprite)
        scaleFactor = self.size * 2.2 / rawWidth # PERFECT!
        
        drawImage(sprite, 
                  *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                  width = render.getScale(rawWidth * scaleFactor), 
                  height = render.getScale(rawHeight * scaleFactor), align = 'center')
        
        if app.debugDraw:
            drawCircle(*render.getCoords(self.pos), render.getScale(self.size), 
                       #rotateAngle = render.getAngle(self.pos),
                       fill = None,
                       border = 'gold', borderWidth = render.getScale(1))

player = Player([0, 0, 0], [0, 0, 0], 50, 100)

# Planets: A big object that can move around in the world
class Planet():
    Instances = set()
    def __init__(self, pos, vel, mass):
        self.pos = pos
        self.vel = vel
        self.mass = mass

        # Set default angle if undefined
        if len(self.pos) < 3:
            self.pos = [ self.pos[0], self.pos[1], 0 ]
        if len(self.vel) < 3:
            self.vel = [ self.vel[0], self.vel[1], 0 ]

        Planet.Instances.add(self)
    
    def __repr__(self):
        return f"Planet, default (s={self.pos}, v={self.vel}, m={self.mass})"
    
    def step(self):
        pass # As per (ideal) implementation of orbit paths, planets do not handle their own motion. They are perfectly parameterized, not simulated
        # Velocity is only stored internally to compute collisions

    def getPosVelData(self):
        return self.pos, self.vel
    
    def setPos(self, newpos):
        self.pos = newpos
    
    def setVel(self, newvel):
        self.vel = newvel

    def setLinearPos(self, newPosition):
        self.pos[0] = newPosition[0]
        self.pos[1] = newPosition[1]

    def setRotationPos(self, newRotation):
        self.pos[2] = newRotation

    def setLinearVel(self, newVelocity):
        self.vel[0] = newVelocity[0]
        self.vel[1] = newVelocity[1]

    def setRotationVel(self, newVelocity):
        self.vel[2] = newVelocity

class SpherePlanet(Planet):
    Instances = set()
    def __init__(self, pos, vel, size, mass, image = None, imageScaler = 1):
        super().__init__(pos, vel, mass)
        # Calling super_init has the added benefit of appending it to the superclass's instance list
        # So this sphereplanet is ALSO contained in the list of general
        self.size = size
        self.image = image

        self.imageScaler = imageScaler

        SpherePlanet.Instances.add(self)

    def __repr__(self):
        return f"Planet, sphere (s={self.pos}, v={self.vel}, m={self.mass}, r={self.size})"
        
    def getNormalVectorTo(self, otherpos):
        xComp = otherpos[0] - self.pos[0]
        yComp = otherpos[1] - self.pos[1]
        return vector.unit((xComp, yComp))

    # Rendering
    def draw(self, app):
        if self.image != None:
            if isinstance(self.image, str) and 'assets' in self.image:
                rawWidth, rawHeight = getImageSize(self.image)
                scaleFactor = self.size * 2.2 * self.imageScaler / rawWidth
                realWidth, realHeight = render.getScale(rawWidth * scaleFactor), render.getScale(rawHeight * scaleFactor)

                drawImage(self.image, 
                    *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                    width = realWidth, height = realHeight, align = 'center')
            else:
                drawCircle(*render.getCoords(self.pos), render.getScale(self.size), fill = self.image)
        if app.debugDraw:
            drawCircle(*render.getCoords(self.pos), 
                        render.getScale(self.size), 
                        #rotateAngle = render.getAngle(self.pos),
                        fill = None,
                        border = 'red', borderWidth = render.getScale(2))

class LinePlanet(Planet):
    Instances = set()
    def __init__(self, centerPos, vel, mass, mesh, image = None, imageScaler = 1):
        super().__init__(centerPos, vel, mass)
        # Wind the mesh counterclockwise
        # All hell will break loose if this mesh isn't wound counterclockwise
        # I swear to god
        self.mesh = mesh
        self.image = image
        self.imageScaler = imageScaler
        self.setCollisionCheckRadius()

        LinePlanet.Instances.add(self)

    def __repr__(self):
        return f"Planet, line (s={self.pos}, v={self.vel}, m={self.mass})"

    # Mesh Helping
    def getWorldspaceMesh(self):
        rotatedOffsets = [
            vector.rotate(thisPoint, self.pos[2])
                for thisPoint in self.mesh
        ]
        return [
            (thisPoint[0] + self.pos[0], 
             thisPoint[1] + self.pos[1]) 
                for thisPoint in rotatedOffsets
        ]
    
    def getLinesFromPoints(self, points):
        # Takes list of size-2 tuples, makes list of size-2 with nested size-2 tuples
        result = []
        for i in range(len(points)):
            # BEGINS by winding last to first
            # then proceeds up the list
            result.append(
                (
                    (points[i-1][0], points[i-1][1]),
                    (points[i][0], points[i][1])
                )
            )
        return result # List of lines, each a 2-length tuple, containing 2 points, each 2-length tuples

    def getWorldMeshLines(self):
        return self.getLinesFromPoints(self.getWorldspaceMesh())
    
    # Collision

    # Calculate and save collision radius
    def setCollisionCheckRadius(self):
        furthestPointDistance = 0
        furthestPoint = None
        for relativePoint in self.mesh:
            # Get radial distance from defined center
            currentDistance = vector.len(relativePoint)
            
            # Set to first, or to furthest away
            if furthestPoint == None or currentDistance > furthestPointDistance:
                furthestPoint = relativePoint
                furthestPointDistance = currentDistance
        # We got the furthest point
        self.collisionCheckRadius = furthestPointDistance

    def getCollisionCheckRadius(self):
        return self.collisionCheckRadius
    
    # Generate, live, expanded meshes depending on provided distance change (radius of colliding smallbody, eventually)
    def generateExpandedLinearMesh(self, d):
        originalLines = self.getWorldMeshLines()

        expandedSegmentMesh = []
        for segment in originalLines:
            lineVector = vector.vectorize(segment)
            normal = vector.unit(vector.cw(lineVector))
            shift = vector.scale(normal, d) # We move along normal vector by d

            newStartPoint = vector.add(segment[0], shift) # The shift is a delta, so this translates the segment points by shift (yay!)
            newEndPoint = vector.add(segment[1], shift)
            expandedSegmentMesh.append((newStartPoint, newEndPoint))
        return expandedSegmentMesh
    
    def generateExpandedCornerMesh(self, d):
        originalLines = self.getWorldMeshLines()

        convexVertices = [] # Name is vestigial. Don't need to avoid putting these in concavities.
        for pointIndex in range(len(originalLines)):
            firstSegment = originalLines[pointIndex - 1] # If the first pair is (-1) and (0), we've successfully wound without exceeding loop indices
            secondSegment = originalLines[pointIndex]

            assert( firstSegment[1] == secondSegment[0] ) # Just gonna leave this here for debugging purposes. These should all be wound such that they have common points
            thisVertex = secondSegment[0] # equivalently, firstSegment[1]
            
            convexVertices.append(thisVertex) # It actually improves sim to have circles in the concavities too. No distinction made between convex and concave
        return convexVertices # Since we know d the entire time, we crunch the numbers on circle intersection outside of this function. Theoretically, it's distance-agnostic.
    
    # Check interiority with internal new mesh generation
    def getExpandedCollisionData(self, testPoint, expandRadius):

        # === # === # === # === #
        # LINEAR MESH COLLIDER
        # === # === # === # === #
        
        # Welcome to hell. This single function, and its connections upstairs in collideWithLines, made for easily ten straight hours of development on Monday, July 28th, 2025.
        # But in all fairness, this is sick as fuck.
        # Circle collisions, of ANY radius, with an arbitrary polygon? Gorgeous.

        # === # === # === # === #
        # PART 1: COLLIDING WITH LINEAR SEGMENTS OF THE EXPOSED MESH
        # === # === # === # === #

        expandedMesh = self.generateExpandedLinearMesh(expandRadius)

        # To dodge any edge cases, we calc interiority by majority vote
        interiorityConsensus = 0

        # Raycast segment generation ( 8 cardinal directions seems to suffice )
        raycastSegments = []
        unitDirections = [(1, 0), (0, 1), (-1, 0), (0, -1), # Eight cardinal directions
                          (0.7, 0.7), (-0.7, 0.7), (-0.7, -0.7), (0.7, -0.7)] # In idgaf terms, sqrt(2)/2 = 0.7
        maxRayLength = self.getCollisionCheckRadius() * 2 # Collision *diameter* means we are guaranteed to cross the entire circle, thus the entire mesh
        rayStart = testPoint
        for rayIndex in range(8):
            # Each endpoint is the respective cardinal unit direction scaled by the max possible radius we'd need to check
            # and of course it needs to be made relative to start, hence vector.add()
            rayEnd = vector.add(rayStart, vector.scale(unitDirections[rayIndex], maxRayLength))
            raycastSegments.append((rayStart, rayEnd))
        
        # Collision counting
        for ray in raycastSegments:
            intersectionCount = 0
            for segment in expandedMesh:
                doesIntersect = self.segmentsIntersect(ray, segment)
                if doesIntersect != False:
                    intersectionCount += 1
                    # Any business about getting the closest intersection
            hasOddIntersections = intersectionCount % 2 == 1
            interiorityConsensus += 1 if hasOddIntersections else -1
        
        # We've collided with lines.
        if interiorityConsensus > 0:
            # Return the closest segment as determined by smallest area via Heron's Formula
            minArea = None
            closestSegment = None
            for segment in expandedMesh:
                area = vector.heronAreaByPoints(*segment, testPoint)
                if minArea == None or area == 0 or area < minArea:
                    closestSegment = segment
                    minArea = area
            
            def segmentToCollisionData(segment):
                # Rotate the (vectorized)segment to get its normal vector
                normal = vector.unit(vector.cw(vector.vectorize(segment)))
                # Via triangle angle formula (A = 1/2 bh), get h = 2 * area / base
                absDepth = 2 * vector.heronAreaByPoints(segment[0], segment[1], testPoint) / vector.len(vector.vectorize(segment))
                return normal, -absDepth # depth should be negative

            return segmentToCollisionData(closestSegment)
        
        # === # === # === # === #
        # PART 2: COLLIDING WITH ROUNDED VERTICES OF THE EXPANDED MESH
        # === # === # === # === #

        expansionVertices = self.generateExpandedCornerMesh(expandRadius)

        for testVertex in expansionVertices:
            if vector.distance(testVertex, testPoint) <= expandRadius: # Colliding with this circle:
                normal = vector.unit(vector.subtract(testPoint, testVertex))
                depth = vector.distance(testVertex, testPoint) - expandRadius # should be negative
                return normal, depth
        
        # Goddamn it. It really puts things into perspective when you can spend ten hours developing a line collider and six lines rewriting a circle one

        return False
            
    def segmentsIntersect(self, line1, line2):
        # Full credit to https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/
        # It's a nice one

        def onSegment(p, q, r):
            return ( q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and
                     q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))
        
        def winding(p, q, r):
            val = ( (q[1] - p[1]) * (r[0] - q[0]) -
                    (q[0] - p[0]) * (r[1] - q[1]) )

            # collinear
            if val == 0:
                return 0
            # 1 for clockwise, 2 for counterclockwise
            return 1 if val > 0 else 2

        # Calculate four windings of subsets of the points (a segment and one end of the other)
        o1 = winding(line1[0], line1[1], line2[0])
        o2 = winding(line1[0], line1[1], line2[1])
        o3 = winding(line2[0], line2[1], line1[0])
        o4 = winding(line2[0], line2[1], line1[1])

        # general case
        if o1 != o2 and o3 != o4:
            return True
        
        # special cases
        # p1, q1 and p2 are collinear and p2 lies on segment p1q1
        if o1 == 0 and onSegment(line1[0], line2[0], line1[1]):
            return True

        # p1, q1 and q2 are collinear and q2 lies on segment p1q1
        if o2 == 0 and onSegment(line1[0], line2[1], line1[1]):
            return True

        # p2, q2 and p1 are collinear and p1 lies on segment p2q2
        if o3 == 0 and onSegment(line2[0], line1[0], line2[1]):
            return True

        # p2, q2 and q1 are collinear and q1 lies on segment p2q2 
        if o4 == 0 and onSegment(line2[0], line1[1], line2[1]):
            return True
        
        return False

    # Rendering
    def draw(self, app):
        if self.image != None:
            if isinstance(self.image, str) and 'assets' in self.image:
                rawWidth, rawHeight = getImageSize(self.image)
                scaleFactor = self.getCollisionCheckRadius() * self.imageScaler / rawWidth
                realWidth, realHeight = render.getScale(rawWidth * scaleFactor), render.getScale(rawHeight * scaleFactor)

                drawImage(self.image, 
                    *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                    width = realWidth, height = realHeight, align = 'center')
            else:
                allPoints = []
                for coord in self.getWorldspaceMesh():
                    coord = render.getCoords(coord)
                    allPoints += [coord[0]]
                    allPoints += [coord[1]]
                drawPolygon(*allPoints, fill = self.image)

        if app.debugDraw:
            for thisLine in self.getLinesFromPoints(self.getWorldspaceMesh()):
                lineStart = render.getCoords(thisLine[0])
                lineEnd = render.getCoords(thisLine[1])
                drawLine(*lineStart, *lineEnd, fill = 'red', lineWidth = render.getScale(2))

class NonCollisionPlanet(Planet):
    Instances = set()
    def __init__(self, pos, vel, size, mass, image = None):
        super().__init__(pos, vel, mass)
        self.size = size
        self.image = image

        NonCollisionPlanet.Instances.add(self)
    
    def draw(self, app):
        if app.debugDraw:
            drawCircle(*render.getCoords(self.pos), 
                        render.getScale(self.size), 
                        fill = None,
                        border = 'red', borderWidth = render.getScale(2),
                        dashes = True)

class BlackHole(Planet):
    Instances = set()
    def __init__(self, pos, vel, size, mass, teleportThresholdSize, pairedWhiteHole:NonCollisionPlanet, image = None):
        super().__init__(pos, vel, mass)
        self.size = size
        self.image = image

        self.teleportThresholdSize = teleportThresholdSize

        self.pairedWhiteHole = pairedWhiteHole

        BlackHole.Instances.add(self)
    
    def isInsideEventHorizon(self, testPos):
        return vector.distance(self.pos, testPos) <= self.teleportThresholdSize

    def checkAndTeleport(self, other:SmallBody):
        if self.isInsideEventHorizon(other.pos):
            destinationPos = motion.getPosAboutCenter(self.pairedWhiteHole.pos, self.pairedWhiteHole.size, randrange(0, 359))
            newTheta = randrange(0, 359)
            other.pos = [destinationPos[0], destinationPos[1], newTheta] # Spit them out
            other.vel = list(vector.add2to3(other.vel, vector.scale(other.vel, -0.5))) # Just to dampen the blow

    def draw(self, app):
        # ART NEEDED
        drawCircle(*render.getCoords(self.pos), 
                        render.getScale(self.size), 
                        #rotateAngle = render.getAngle(self.pos),
                        fill = 'black')
        
        if app.debugDraw:
            drawCircle(*render.getCoords(self.pos), 
                        render.getScale(self.size), 
                        rotateAngle = render.getAngle(self.pos),
                        fill = 'black',
                        border = 'indigo', borderWidth = render.getScale(2))
            drawCircle(*render.getCoords(self.pos),
                       render.getScale(self.teleportThresholdSize),
                       rotateAngle = render.getAngle(self.pos),
                       fill = None,
                       border = 'gold', borderWidth = render.getScale(2))

# Bonus Fruit Behaviors
class FruitSpawner():
    Instances = set()
    def __init__(self, fruitToSpawn:str, relativeBody:Planet, thetaPosition, radialPosition, maxInstances:int, respawnTickThreshold:int, randomVelJitter = 0):
        self.myFruit = fruitToSpawn
        self.relativeBody = relativeBody
        self.thetaPosition = thetaPosition

        if radialPosition == 'default':
            self.radialPosition = self.relativeBody.size + Fruit.typeDict[self.myFruit]['Size'] * 2
        else:
            self.radialPosition = radialPosition

        self.spawnedFruit = set()
        self.maxInstances = maxInstances

        self.respawnTick = 0
        self.respawnTickThresold = respawnTickThreshold

        self.jitterThresh = randomVelJitter

        FruitSpawner.Instances.add(self)
    
    def getSpawnPoint(self):
        if self.radialPosition == 0:
            return self.relativeBody.pos
        else:
            return list(motion.getPosAboutCenter(self.relativeBody.pos, self.radialPosition, 
                                                 self.thetaPosition + self.relativeBody.pos[2]))
        
    def getSpawnVel(self):
        if self.jitterThresh != 0:
            randomTheta = randrange(0, 360)
            randomMagnitude = random() * self.jitterThresh # from 0x to 1x the specified threshold
            randomJitterVector = vector.rotate((randomMagnitude, 0), randomTheta)
        
            return list(vector.add(self.relativeBody.vel, randomJitterVector)) + [0]
        else:
            return list(self.relativeBody.vel)
    
    def spawnOneFruit(self):
        self.spawnedFruit.add( Fruit(self.getSpawnPoint(), self.getSpawnVel(), self.myFruit) )  

    def step(self):
        self.respawnTick += 1
        if self.respawnTick >= self.respawnTickThresold:
            # Attempts to spawn a new fruit after every specified tick duration
            if len(self.spawnedFruit) < self.maxInstances:
                self.spawnOneFruit()
            # Always reset the clock anyway
            self.respawnTick = 0

    def draw(self, app):
        if app.debugDraw:
            drawStar(*render.getCoords(self.getSpawnPoint()), render.getScale(15), 5, fill = 'gold')

class PlayerFruitSpawner():
    # Enough has changed that I found it easier to make a new category of launcher specifically here
    # and it's not that difficult to just call set union on normal and player spawner instances elsewhere

    Instances = set()
    def __init__(self):
        self.relativeBody = player
        self.relativeTheta = 90

        self.spawnedFruit = set()

        PlayerFruitSpawner.Instances.add(self)

    # Spawn preparation
    def getSpawnPos(self, fruitRadius):
        return list(motion.getPosAboutCenter(player.pos, player.size + fruitRadius * 2, 
                                                 self.relativeTheta - player.pos[2]))

    def getSpawnVel(self):
        forwardThrowFactor = 2
        forwardVector = vector.rotate((0, 1), player.pos[2]) # (0, 1) represents forward, perfect for our case
        return list(vector.add(player.vel, vector.scale(forwardVector, forwardThrowFactor))) + [0]
    
    # Instantiate a new fruit out of ourselves
    def launchOneFruit(self, app):
        if len(player.fruitInventory) > 0: # Still at least one in the tank
            fruitToLaunchType = player.fruitInventory.pop() # Removes it from the inventory inherently
            fruitToLaunchSize = Fruit.typeDict[fruitToLaunchType]['Size']
            launchPos = self.getSpawnPos(fruitToLaunchSize)
            launchVel = self.getSpawnVel()
            self.spawnedFruit.add(Fruit(launchPos, launchVel, fruitToLaunchType))
            if app.debugPrint:
                print("We launched one fruit, type", fruitToLaunchType)

    def draw(self, app):
        if app.debugDraw and len(player.fruitInventory) > 0:
            drawStar(*render.getCoords(self.getSpawnPos(20)), render.getScale(5), 5, fill = 'gold')

playerCannon = PlayerFruitSpawner()

class ScoreBucket():
    Instances = set()
    def __init__(self, relativeBody, thetaPosition, radialPosition, consumptionRadius):
        self.relativeBody = relativeBody
        self.thetaPosition = thetaPosition

        if radialPosition == 'default':
            self.radialPosition = self.relativeBody.size
        else:
            self.radialPosition = radialPosition

        self.size = consumptionRadius

        self.totalCollected = 0
        self.collectedDict = {
            'grape': 0,
            'apple': 0,
            'raspberry': 0,
            'blackberry': 0,
            'peach': 0,
            'fig': 0
        }
        self.score = 0

        self.playerNearby = False

        ScoreBucket.Instances.add(self)
    
    def step(self, app):
        self.checkFruitCollisions(app)
        if vector.distance(self.getCenterPoint(), player.pos) <= self.size * 5:
            self.playerNearby = True
        else:
            self.playerNearby = False

    def getCenterPoint(self):
        return list(motion.getPosAboutCenter(self.relativeBody.pos, self.radialPosition, 
                                             self.thetaPosition + self.relativeBody.pos[2]))
    
    def checkFruitCollisions(self, app):
        for spawner in FruitSpawner.Instances | PlayerFruitSpawner.Instances:
            for possibleFruit in spawner.spawnedFruit: 
                if vector.distance(self.getCenterPoint(), possibleFruit.pos) <= self.size + possibleFruit.size:
                    # Pass both fruit and spawner to clearign function, as there's no global fruit location
                    Player.appendFruitCullList(app, spawner, possibleFruit)

                    # Tick one up
                    self.totalCollected += 1
                    self.collectedDict[possibleFruit.getType()] += 1
                    self.score += Fruit.typeDict[possibleFruit.getType()]['Score']
                    if app.debugPrint:
                        print("Score inventory is now:", self.collectedDict)
                        print("Total score:", self.score)
    
    def getScoreDict(self):
        return self.collectedDict
    def getTotalCounts(self):
        return self.totalCollected
    def getTotalScore(self):
        return self.score

    def draw(self, app):
        if self.playerNearby:
            self.drawScoreboard(app)
        if app.debugDraw:
            drawStar(*render.getCoords(self.getCenterPoint()), render.getScale(30), 5, fill = 'orchid')
            drawCircle(*render.getCoords(self.getCenterPoint()), render.getScale(self.size), fill = None,
                       border = 'orchid', borderWidth = render.getScale(2))
            
    def drawScoreboard(self, app):
        scoreDict = lazulaBucket.getScoreDict()
        score = lazulaBucket.getTotalScore()
        count = lazulaBucket.getTotalCounts

        x = app.width * 0.8
        y = app.height * 0.5

        drawLabel(f'Score:{score}', x, y - 100, size = 30, fill = 'gold')
        #print("We have the score dictionary", scoreDict)
        
        for i in range(len(scoreDict)):
            listTypes = ['grape', 'apple', 'raspberry', 'blackberry', 'peach', 'fig']
            height = y - 60 + 40 * i
            size = 20
            fruitType = listTypes[i]
            fruitCount = scoreDict[fruitType]

            text = f'{fruitType} count: {fruitCount}'
            drawLabel(text, x, height, size = size, fill = 'lavender')
               
# === CLASSES: MOVEMENT CONTROLLERS ===

class Path():
    @staticmethod
    def globalInitializePosition(planetToInitialize):
        planetToInitialize.setPos([0, 0, 0])
        planetToInitialize.setVel([0, 0, 0])

class OrbitPath():
    Instances = set()
    def __init__(self, adoptedPlanet):
        assert(isinstance(adoptedPlanet, Planet))
        self.pathedPlanet = adoptedPlanet

        self.orbitT = 0 # Increases evenly up to 360
        self.maxT = 360

        OrbitPath.Instances.add(self)
    
    # Object definition

    def defineOrbit(self, orbitCenter, radius, degreesPerSecond, initialTheta = 0): # speed in deg / sec
        assert( isinstance(orbitCenter, Planet) or 
               isinstance(orbitCenter, tuple) or 
               isinstance(orbitCenter, list) )
        if isinstance(orbitCenter, Planet):
            self.orbitCenterPos = orbitCenter.pos # Hopefully we can directly alias these together
            self.orbitCenterVel = orbitCenter.vel # DO NOT MODIFY THIS DIRECTLY AS TO NOT BREAK ALIASING. DON'T FUCKING DO IT
        else:
            self.orbitCenterPos = orbitCenter[:2] # If a provided tuple or list. Centerbody-rotation agnostic. Both, awesomely, can be sliced
            self.orbitCenterVel = [0, 0]

        self.orbitRadius = radius

        self.degreesPerStep = degreesPerSecond / 30

        self.orbitT = initialTheta # Just get it started. No beating around the bush

        def circularOrbitFunc(theta):
            initialPos = (self.orbitRadius, 0) # zero theta corresponds to +x, as trigonometry mandates
            return vector.rotate(initialPos, theta)

        self.orbitFunction = circularOrbitFunc # Now we can call orbitfunction and it should give us the desired position based on T

    @staticmethod
    def initalize():
        for thisOrbit in OrbitPath.Instances:
            thisOrbit.initializeOrbitPosition()

    def initializeOrbitPosition(self):
        pass # lowkey... since step is always hard-setting the position, I actually don't need to move it anywhere.
        # It requires that aliasing to the center pos and velocity didn't work. If it doesn't...
        # That's an entirely different story
    
    def step(self):
        # Calculate current position along trajectory
        self.orbitT = (self.orbitT + self.degreesPerStep) % self.maxT

        # Calculate current relative position
        currentRelativeOrbitPos = self.orbitFunction(self.orbitT)

        # Calculate current relative velocity
        futureRelativeOrbitPos = self.orbitFunction(self.orbitT + self.degreesPerStep)
        relativeVelocity = vector.subtract(futureRelativeOrbitPos, currentRelativeOrbitPos)

        # Calculate current world position and velocity
        currentWorldOrbitPos = vector.add(currentRelativeOrbitPos, self.orbitCenterPos) # Run checks to make sure this CHANGES if we parent to a moving body
        currentWorldOrbitVel = vector.add(relativeVelocity, self.orbitCenterVel)

        # Push to planet
        self.pathedPlanet.setLinearPos(currentWorldOrbitPos)
        self.pathedPlanet.setLinearVel(currentWorldOrbitVel)
    
class RotatingPath():
    Instances = set()
    def __init__(self, adoptedPlanet):
        assert(isinstance(adoptedPlanet, Planet))
        self.pathedPlanet = adoptedPlanet

        self.rotationT = 0
        self.maxT = 360
        # In this system, rotationT corresponds 1-1 from path theta to planet rotation

        RotatingPath.Instances.add(self)
    
    # Object definition
    
    def defineRotation(self, degreesPerSecond, initialTheta = 0): # Called in object definition
        degreesPerTick = degreesPerSecond / 30

        self.rotationT = initialTheta
        self.speed = degreesPerTick

    # App initialization

    @staticmethod
    def initalize():
        for thisRotation in RotatingPath.Instances:
            thisRotation.initializeRotation()
    
    def initializeRotation(self): # Called on app start
        pass
        #self.pathedPlanet.setRotationPos(self.rotationT)
    
    def step(self):
        # Calculate where the planet should be, and then plug it straight in
        self.rotationT = (self.rotationT + self.speed) % self.maxT
        self.pathedPlanet.setRotationPos(self.rotationT)
        self.pathedPlanet.setRotationVel(self.speed)

# === GAME OBJECT INSTANCING ===

# ALL (CORE) POSITION & VELOCITY VECTORS ARE ARE LISTS NOW
# WE LOVE MUTABILITY
# frankly there should be an additional kind of data type, with a set number of slots but is perfectly able to change data within them

somberHeartMesh = [
        (300, 300), # top inner lip
        (400, 500), (0, 600), (-350, 500), # very top
        (-500, 300), (-600, 0), (-500, -300), # back plate
        (-350, -500), (100, -650), (500, -500), # very bottom
        (400, -300), # bottom inner lip
        (0, -400), (-300, -250), (-400, 0), (-300, 250), (0, 400) # interior
    ]

SomberHeart = LinePlanet([0, 0], [0, 0], 0, somberHeartMesh, gradient("fireBrick", 'navy'))

SomberOutlet = NonCollisionPlanet([0, 0], [0, 0], 20, 0) # I want to try negative mass so badly
SomberCore = BlackHole([0, 0], [0, 0], 150, 11000, 200, SomberOutlet)

# Could I have iterated these ones? Certainly. Did I? Not on this timeframe. 
RubyCore = NonCollisionPlanet([0, 0], [0, 0], 15, 0)

RubyBrambleOne = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Ruby Bramble.png')
RubyBrambleTwo = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Ruby Bramble.png')
RubyBrambleThree = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Ruby Bramble.png')

SapphireCore = NonCollisionPlanet([0, 0], [0, 0], 15, 0)

SapphireBrambleOne = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Sapphire Bramble.png')
SapphireBrambleTwo = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Sapphire Bramble.png')
SapphireBrambleThree = SpherePlanet([0, 0], [0, 0], 150, 500, 'assets/planets/Sapphire Bramble.png')

LazulaVine = SpherePlanet([0, 0], [0, 0], 500, 1250, gradient('orchid', 'darkSlateBlue'))

MysteriousMan = SpherePlanet([0, 0], [0, 0], 1000, 1500)
MysteriousMoon = SpherePlanet([0, 0], [0, 0], 150, 1500)

player.setPos([10000, 500, 0]) # Positioned by hand on top of Lazula Vine

centerOfTheUniverse = Helperball([0, 0], 50, 'black')

# === PATH INSTANCING ===

# First and solidly first: for every planet relevant to the path system, call globalInitializePosition
# Let's assume every single one is called at least once. Why not?
# If not, you must specify manually which planets get this initialize statement run on them.
for planet in Planet.Instances:
    Path.globalInitializePosition(planet)

# Then, define an appropriate path object for each planet you desire.
# Follow that with the appropriate define method, which specifies relevant characteristics to the path

# Somber Heart
somberSpin = RotatingPath(SomberHeart)
somberSpin.defineRotation(5, 0)

somberGrove = FruitSpawner('fig', SomberHeart, 180, 650, 3, 250, 2)

# Variables for bramble
brambleCoreRadius = 2000
brambleCoreSpeed = 10
brambleBallRadius = 250
brambleBallSpeed = -20

# Ruby Bramble
rubyCoreOrbit = OrbitPath(RubyCore)
rubyCoreOrbit.defineOrbit((0, 0), brambleCoreRadius, brambleCoreSpeed, 45)

rubyOneOrbit = OrbitPath(RubyBrambleOne)
rubyOneOrbit.defineOrbit(RubyCore, brambleBallRadius, brambleBallSpeed, 0)
rubyTwoOrbit = OrbitPath(RubyBrambleTwo)
rubyTwoOrbit.defineOrbit(RubyCore, brambleBallRadius, brambleBallSpeed, 120)
rubyThreeOrbit = OrbitPath(RubyBrambleThree)
rubyThreeOrbit.defineOrbit(RubyCore, brambleBallRadius, brambleBallSpeed, 240)

rubyOneSpin = RotatingPath(RubyBrambleOne)
rubyOneSpin.defineRotation(brambleBallSpeed, 0)
rubyTwoSpin = RotatingPath(RubyBrambleTwo)
rubyTwoSpin.defineRotation(brambleBallSpeed, 120)
rubyThreeSpin = RotatingPath(RubyBrambleThree)
rubyThreeSpin.defineRotation(brambleBallSpeed, 240)

rubyGrove = FruitSpawner('raspberry', RubyCore, 0, 0, 3, 75, 0.1)

# Sapphire Bramble
sapphireCoreOrbit = OrbitPath(SapphireCore)
sapphireCoreOrbit.defineOrbit((0, 0), brambleCoreRadius, brambleCoreSpeed, 225)

sapphireOneOrbit = OrbitPath(SapphireBrambleOne)
sapphireOneOrbit.defineOrbit(SapphireCore, brambleBallRadius, brambleBallSpeed, 60)
sapphireTwoOrbit = OrbitPath(SapphireBrambleTwo)
sapphireTwoOrbit.defineOrbit(SapphireCore, brambleBallRadius, brambleBallSpeed, 180)
sapphireThreeOrbit = OrbitPath(SapphireBrambleThree)
sapphireThreeOrbit.defineOrbit(SapphireCore, brambleBallRadius, brambleBallSpeed, 300)

sapphireOneSpin = RotatingPath(SapphireBrambleOne)
sapphireOneSpin.defineRotation(brambleBallSpeed, 0)
sapphireTwoSpin = RotatingPath(SapphireBrambleTwo)
sapphireTwoSpin.defineRotation(brambleBallSpeed, 120)
sapphireThreeSpin = RotatingPath(SapphireBrambleThree)
sapphireThreeSpin.defineRotation(brambleBallSpeed, 240)

sapphireGrove = FruitSpawner('blackberry', SapphireCore, 0, 0, 3, 75, 0.1)

# Lazula Vine
lazulaOrbit = OrbitPath(LazulaVine)
lazulaOrbit.defineOrbit((0, 0), 10000, 0.01, 0)

lazulaSpin = RotatingPath(LazulaVine)
lazulaSpin.defineRotation(5, 0)

# Native fruit patch to Lazula
lazulaGroveOne = FruitSpawner('grape', LazulaVine, 0, 'default', 3, 50, 0.8)

# The one and only consumer bucket
lazulaBucket = ScoreBucket(LazulaVine, -90, LazulaVine.size, 100)

# Lazula's weirdest moon, Somber Outlet
outletOrbit = OrbitPath(SomberOutlet)
outletOrbit.defineOrbit(LazulaVine, 750, -1)

# The empty ones
mysManOrbit = OrbitPath(MysteriousMan)
mysManOrbit.defineOrbit((0, 0), 15000, 0.025, 320)
mysMoonOrbit = OrbitPath(MysteriousMoon)
mysMoonOrbit.defineOrbit(MysteriousMan, 1000, 0.1, 120)

# === CLASSES: RENDERING ===

class Render():
    # FUNDAMENTALS
    def __init__(self, app):
        self.renderOrigin = (app.width * 0.5, app.height * 0.5)
        self.scale = 1
        self.scaleChangeDirection = 0
        self.setRenderOrigin(app)

        self.globalAngleAdjustment = 0
    
    def step(self, app):
        self.setRenderOrigin(app)
        self.stepScale()

    def draw(self, app):
        self.internal_drawRenderOrigin(app)
    
    # SCREEN ORIGIN
    def setRenderOrigin(self, app, posX = 0.5, posY = 0.5):
        self.renderOrigin = (app.width * posX, app.height * posY)

    def internal_drawRenderOrigin(self, app):
        drawCircle(*self.renderOrigin, 3 * self.scale, fill = 'black')

    # MASTER RENDERING
    # Master renderer, spits out coordinates shifted by player's position, rotation, screen scale, and screen position
    def getCoords(self, posTuple):
        xReal, yReal = posTuple[0], posTuple[1]
        if len(posTuple) == 3: # I want it to accept both coord and coord + rotation
            thetaReal = posTuple[2]
        else:
            thetaReal = None

        xCam, yCam = player.pos[0], player.pos[1]
        thetaCam = player.pos[2] + self.globalAngleAdjustment
        
        # Shift the coordinates in realspace to put the camera at origin, scale all as well
        tx, ty = self.internal_renderTranslate(xReal, yReal, xCam, yCam)
        rx, ry = self.internal_renderRotate(tx, ty, thetaCam)
        finalx, finaly = self.internal_renderScale(rx, ry)
        
        # Shift to render scheme
        return self.internal_renderScreenshift(finalx, finaly)

    # Rotation handler for non-point objects (CMU graphics bodies, images)
    def getAngle(self, rotationCoord): 
        trueBodyAngle = rotationCoord[2] if isinstance(rotationCoord, tuple) or isinstance(rotationCoord, list) else rotationCoord
        return trueBodyAngle - player.pos[2] - self.globalAngleAdjustment
    
    # Scale handler for non-point objects
    def getScale(self, normalScale):
        return normalScale * self.scale

    # MASTER RENDER HELPERS 
    # Translation helper
    def internal_renderTranslate(self, x, y, cx, cy):
        return x - cx, y - cy

    # Rotation helper
    def internal_renderRotate(self, x, y, theta):
        theta = math.radians(theta)
        rotatedX = math.cos(theta) * x - math.sin(theta) * y
        rotatedY = math.sin(theta) * x + math.cos(theta) * y
        return rotatedX, rotatedY

    # Scale helper
    def internal_renderScale(self, x, y):
        return x * self.scale, y * self.scale

    # Turning to screen coordinate helper
    def internal_renderScreenshift(self, x, y):
        return self.renderOrigin[0] + x, self.renderOrigin[1] - y
    
    
    # SCALE
    # Changes screen scale based on current state of self.scaleChangeDirection
    def stepScale(self):
        scaleMax = 5
        scaleMin = 0.2
        # Short circuit if it's even relevant, then ensure within bounds
        if (self.scaleChangeDirection != 0 and
            (self.scaleChangeDirection == 1 and self.scale < scaleMax) or 
            (self.scaleChangeDirection == -1 and self.scale > scaleMin)):
                scaleFactor = 1 + (0.1 * self.scaleChangeDirection)
                self.scale *= scaleFactor

    # MOUSE HANDLING
    #def save

class UnRender():
    # Unrender serves a fascinating vestigial purpose
    # On two occasions I envisioned I'd incorporate the mouse position as a world-based coordinate
    # For either an object that floated where the mouse was, or to fire an object in its direction
    # And though there are roundabout solutions to answering that question, here is the most immediate:
    # How elegantly could I 100% reverse-engineer my rendering code, such that any inputted screen position
    # knows its exact coordinate in the world?

    # There wasn't quite enough time before term project deadline, but nonetheless,
    # this seems an interesting monument.
    def getWorldCoords(self, screenCoordinate):

        def unScreenshift(xScreen, yScreen):
            return xScreen - render.renderOrigin[0], -yScreen + render.renderOrigin[1]
        def unScale(xScaled, yScaled):
            return xScaled / self.scale, yScaled / self.scale
        def unRotate(xRotated, yRotated):
            theta = math.radians(player.pos[2] + render.globalAngleAdjustment) * -1 
            unRotatedX = math.cos(theta) * xRotated - math.sin(theta) * yRotated
            unRotatedY = math.sin(theta) * xRotated + math.cos(theta) * yRotated
            return unRotatedX, unRotatedY
        def unTranslate(xMoved, yMoved):
            return xMoved + player.pos[0], yMoved + player.pos[1]
        
        xScreen, yScreen = screenCoordinate[0], screenCoordinate[1]
        return unTranslate(unRotate(unScale(unScreenshift(xScreen, yScreen)))) # The majesty

render = Render(app)

unrender = UnRender()

# === EVENT HANDLING ===

# STEP

def onStep(app):
    screenHandler.step()
    if app.gameStatus != 'paused':
        takeStep(app)

def takeStep(app):
    for path in OrbitPath.Instances | RotatingPath.Instances:
        path.step()

    for body in SmallBody.Instances:
        body.step(app)
    
    for planet in Planet.Instances:
        planet.step()

    for spawner in FruitSpawner.Instances:
        spawner.step()
    
    for bucket in ScoreBucket.Instances:
        bucket.step(app)

    # Fruit nonsense
    Player.emptyFruitCullList(app)

    # Rendering
    render.step(app)

# KEY INPUT

def onKeyPress(app, key):
    if app.gameStatus == 'game':
        player.thrustKeysPressed(key)
        player.generalKeysPressed(app, key)

    if app.gameStatus == 'start' and key == 'enter': # Begin with enter at the beginning
        screenHandler.setGame(app)
    
    if key == 'p': # Toggle game and paused with p
        if app.gameStatus == 'game':

            
            screenHandler.setPause(app)
        elif app.gameStatus == 'paused':
            screenHandler.setGame(app)


def onKeyHold(app, key):
    if app.gameStatus == 'game':
        player.thrustKeysHeld(key)
        player.generalKeysHeld(app, key)

def onKeyRelease(app, key):
    if app.gameStatus == 'game':
        player.thrustKeysReleased()
        player.generalKeysReleased(app, key)

# DRAWING

def redrawAll(app): 
    render.setRenderOrigin(app)

    # Specifically putting background in back
    player.drawBackground(app)

    # Game objects
    for objectClass in [SmallBody, Planet]:
        for instance in objectClass.Instances:
            instance.draw(app)

    # Debug objects
    for thisSpawner in FruitSpawner.Instances | PlayerFruitSpawner.Instances:
        thisSpawner.draw(app)

    for thisBucket in ScoreBucket.Instances:
        thisBucket.draw(app)

    # Screen
    screenHandler.draw(app)

# === APP INITIALIZATION ===

def debugGamut(app):
    barrierString = '====='.join('#.#.#.#.#.#.#.#'.split('.'))

    print(barrierString)
    for objectClass in [Helperball, Helperline, SmallBody, Planet]:
        print("Now calling objects of", objectClass)
        for instance in objectClass.Instances:
            print(instance)
        print()
    print(barrierString)

def onAppStart(app):
    debugGamut(app)

    RotatingPath.initalize()
    OrbitPath.initalize()

    # Game setup
    Player.startFruitCullList(app)

    # Game state
    screenHandler.setStart(app)

    app.stepsPerSecond = 30
    app.bigG = 20
    app.debugPrint = False
    app.debugDraw = True

# === MAIN ===

def main():
    #runApp(width = 800, height = 800)
    runApp(width = 1600, height = 1200)

main()