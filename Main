# Main.py

# Spacefruit the Game
# Main file
# By Alexander Werth
# Andrew ID: awerth2
# Recitation: U

from cmu_graphics import *
import math


# === MATH HELPERS ===

# Geometry
def hypotenuse(a, b):
    return (a ** 2 + b ** 2) ** 0.5

def distance(x1, y1, x2, y2):
    return( (y2 - y1) ** 2 + (x2 - x1) ** 2 ) ** 0.5

# 2D Vectors
def vecUnit(x, y): # Normalizes to vector of magnitude 1
    return x / hypotenuse(x,y), y / hypotenuse(x, y)

def vecDot(x1, y1, x2, y2): # Componentwise dot product
    return x1 * x2 + y1 * y2 # turns out it's not very special

def vecTheta(x1, y1, x2, y2): # Angle between lines, a la dot product
    # Crunches the two definitions of dot product,
    #   (sum of component products) = |a||b|cos(theta)
    # , evaluating for theta
    return math.acos( vecDot(x1, y1, x2, y2) / 
                    ( hypotenuse(x1, y1) * hypotenuse(x2, y2) ) )

# Planet tools
def centerDistance(pos1, pos2):
    return distance(pos1[0], pos1[1], pos2[0], pos2[1])

# === DEBUG OBJECTS ===

# A drawn object
class Helperball():
    def __init__(self, centerPos, size, color = 'black'):
        self.centerPos = centerPos
        self.size = size
        self.color = color
    
    def draw(self, app):
        drawCircle(*renderCoords(app, self.centerPos), self.size * app.scale, fill = self.color)

class Helperline():
    def __init__(self, startPos, endPos, thickness, color = 'black'):
        self.startPos = startPos
        self.endPos = endPos
        self.color = color
        self.thickness = thickness
    
    def draw(self, app):
        drawLine(*renderCoords(app, self.startPos), *renderCoords(app, self.endPos), lineWidth = self.thickness * app.scale, fill = self.color)

# === OBJECTS ===



# A small object that collides with planets
class SmallBody():
    def __init__(self, pos, vel, size, mass):
        self.pos = pos
        self.vel = vel
        self.size = size
        self.mass = mass

    def collide(self):
        # Handle collisions with spherical planets
        for thisPlanet in SpherePlanet.Planets:
            planetCenter = thisPlanet.pos
            planetMass = thisPlanet.mass

            
        pass

class Player(SmallBody):
    def __init__(self, pos, vel, thrust, size, mass):
        self.pos = pos
        self.vel = vel
        self.thrust = thrust
        self.size = size
        self.mass = mass

        self.constants = {
            'thrustForce': 0.1,
            'rollForce': 0.1,
            'minimumLinearSpeed': 0.001,
            'minimumRotationalSpeed': 0.005,
            'constantThrustDrag': 0.02,
            'constantRollDrag': 0.04
        }

    def draw(self, app):
        drawCircle(*renderCoords(app, self.pos), self.size * app.scale, fill = 'blue')
        drawLine(*renderCoords(app, self.pos), *renderCoords(app, (self.pos[0], self.pos[1] + 5)), fill = 'black')


    # Control methods
    def thrustKeysPressed(self, key):
        if key in {'w', 'a', 's', 'd'}:
            player.thrust = [
                ( int(key == 'w') - int(key == 's') ) * self.constants['thrustForce'],
                ( int(key == 'd') - int(key == 'a') ) * self.constants['rollForce']
            ]

    def thrustKeysHeld(self, keyList):
        setKeys = set(keyList)
        if setKeys.intersection({'w', 'a', 's', 'd'}) != set(): # Non-empty intersection, so at least 1 is held
            player.thrust = [
                ( int('w' in setKeys) - int('s' in setKeys) ) * self.constants['thrustForce'],
                ( int('d' in setKeys) - int('a' in setKeys) ) * self.constants['rollForce']
            ]
    
    def thrustKeysReleased(self):
        player.thrust = [0, 0]

    def generalKeysPressed(self, app, key):
        pass
    
    def generalKeysHeld(self, app, keyList):
        app.scaleChangeDirection = int('up' in keyList) - int('down' in keyList)

    def generalKeysReleased(self, app, key):
        app.scaleChangeDirection = 0


# A big object that can move around in the world
class Planet():
    Planets = []

    def __init__(self, pos, vel, mass):
        self.pos = pos
        self.vel = vel
        self.mass = mass

# Simplified to collide as a ball
class SpherePlanet():
    Planets = []

    def __init__(self, pos, vel, mass, size, color):
        self.pos = pos
        self.vel = vel
        self.mass = mass
        self.color = color
        self.size = size

        self.collisionRadius = self.size

        SpherePlanet.Planets.append(self)

        # Set pos angle to default if not defined
        if len(self.pos) < 3:
            self.pos = (
                self.pos[0],
                self.pos[1],
                0 # Default angle
            )

    # Collision Mesh Generation
    def setCollisionMesh(self, sizeChange):
        self.collisionRadius = self.size + sizeChange

    # Motion
    def rotate(self, rotateAmount):
        self.pos[2] += rotateAmount
    def orbit(self, centerPos, orbitAmount):
        pass

    # Rendering
    def draw(self, app):
        drawCircle(*renderCoords(app, self.pos), 
                    self.size * app.scale, 
                    rotateAngle = renderAngle(self.pos),
                    fill = self.color)
    
    def drawCollider(self, app):
        drawCircle(*renderCoords(app, self.pos), 
                   self.collisionRadius * app.scale, 
                   rotateAngle = renderAngle(self.pos),
                   fill = None, border = 'red', dashes = True)

# Collides as a polygonal mesh
class LinePlanet():
    Planets = []

    def __init__(self, centerPos, vel, mass, mesh):
        self.pos = centerPos
        self.vel = vel
        self.mass = mass
        self.mesh = mesh
        LinePlanet.Planets.append(self)

    # Mesh Helping
    def getRealCoordinates(self):
        return [
            (thisPoint[0] + self.pos[0], 
             thisPoint[1] + self.pos[1]) 
                for thisPoint in self.mesh
        ]
    
    def getLinesFromPoints(self, points):
        # Takes list of size-2 tuples, makes list of size-4
        result = []
        for i in range(len(points)):
            # BEGINS by winding last to first
            # then proceeds up the list
            result.append(
                (
                    points[i-1][0],
                    points[i-1][1],
                    points[i][0],
                    points[i][1]
                )
            )
        return result # Range of 4-length tuples, line coordinates
    
    def printThisBody(self):
        print( self.getLinesFromPoints(self.getRealCoordinates()) )

    def setCollisionMesh(self, size):
        for pointIndex in range(len(self.mesh)):
            thisPointToExtend = self.mesh[pointIndex]
        pass

# === GLOBAL OBJECT GENERATION

# WRANGLING OBJECTS

# Master collision mesh generator, so I can pass in player class object
def generateCollisionMeshes():
    for thisPlanet in SpherePlanet.Planets:
        thisPlanet.setCollisionMesh(player.size)
    for thisPlanet in LinePlanet.Planets:
        thisPlanet.setCollisionMesh(player.size)

# INSTANCING
Apple = SpherePlanet(
    (100, -100),
    (0, 0),
    100,
    50,
    'red'
)

Quadrangle = LinePlanet(
    (-100, -100),
    (0, 0),
    100,
    [(-10, -10), (-10, 10), (10, 10), (10, -10)]
)

player = Player([-30, 0, 0], [0, 0, 0], [0, 0], 30, 1)
greenBallBall = Helperball((600, 200), 300, 'green')
greenBallLine = Helperline((600, 200), (600, 600), 5, 'black')

greenPlanet = SpherePlanet((500, 200), (0, 0), 30, 300, 'green')

# === RENDERING ===

# SCREEN ORIGIN

# Placing the origin at the screen center
def setRenderOrigin(app, posX = 0.5, posY = 0.5):
    app.renderOrigin = (app.width * posX, app.height * posY)

def drawRenderOrigin(app):
    drawCircle(*app.renderOrigin, 3 * app.scale, fill = 'black')

# HELPERS FOR MASTER RENDERING

# Translation helper
def renderTranslate(x, y, cx, cy):
    return x - cx, y - cy

# Rotation helper
def renderRotate(x, y, theta):
    theta = math.radians(theta)
    rotatedX = math.cos(theta) * x - math.sin(theta) * y
    rotatedY = math.sin(theta) * x + math.cos(theta) * y
    return rotatedX, rotatedY

# Scale helper
def renderScale(app, x, y):
    return x * app.scale, y * app.scale

# Turning to screen coordinate helper
def renderScreenshift(app, x, y):
    return app.renderOrigin[0] + x, app.renderOrigin[1] - y

# MASTER RENDERING

# Master renderer, spits out coordinates shifted by player's position, rotation, screen scale, and screen position
def renderCoords(app, posTuple):
    xReal, yReal = posTuple[0], posTuple[1]
    if len(posTuple) == 3: # I want it to accept both coord and coord + rotation
        thetaReal = posTuple[2]
    else:
        thetaReal = None

    xCam, yCam = player.pos[0], player.pos[1]
    thetaCam = player.pos[2]
    
    # Shift the coordinates in realspace to put the camera at origin, scale all as well
    tx, ty = renderTranslate(xReal, yReal, xCam, yCam)
    rx, ry = renderRotate(tx, ty, thetaCam)
    finalx, finaly = renderScale(app, rx, ry)
    
    # Shift to render scheme
    return renderScreenshift(app, finalx, finaly)

# Rotation handler for non-point objects (CMU graphics bodies, images)
def renderAngle(rotationCoord): 
    trueBodyAngle = rotationCoord[2] if isinstance(rotationCoord, tuple) else rotationCoord
    return trueBodyAngle - player.pos[2] 

# SCALE MANAGEMENT AND CONTROL

# Initialize screen scale
def setScaleStart(app):
    app.scale = 1
    app.scaleChangeDirection = 0

# Changes screen scale based on current state of app.scaleChangeDirection
def stepScale(app):
    scaleMax = 5
    scaleMin = 0.1
    # Short circuit if it's even relevant, then ensure within bounds
    if (app.scaleChangeDirection != 0 and
        (app.scaleChangeDirection == 1 and app.scale < scaleMax) or 
        (app.scaleChangeDirection == -1 and app.scale > scaleMin)):
            scaleFactor = 1 + (0.1 * app.scaleChangeDirection)
            app.scale *= scaleFactor

# === PHYSICS MATHEMATICS ===

# PLAYER PHYSICS
def takePlayerPhysicsStep(app):
    fNetx, fNety = calcPlayerNetForce(app)
    # Acceleration, velocity, position
    ddx = fNetx / player.mass
    ddy = fNety / player.mass
    ddTheta = calcPlayerNetTorque(app) / player.mass

    player.vel[0] += ddx
    player.vel[1] += ddy
    player.vel[2] += ddTheta

    snapVelocitiesToZero()
    
    player.pos[0] += player.vel[0]
    player.pos[1] += player.vel[1]
    player.pos[2] += player.vel[2]
    
def calcPlayerNetForce(app):
    fNetx, fNety = 0, 0 
    fNetx += player.thrust[0] * math.sin(math.radians(player.pos[2]))
    fNety += player.thrust[0] * math.cos(math.radians(player.pos[2]))

    dxPlanet = greenBallBall.centerPos[0] - player.pos[0]
    dyPlanet = greenBallBall.centerPos[1] - player.pos[1]

    bigG = 30
    fNetx += ( bigG * player.mass / (dxPlanet ** 2 + dyPlanet ** 2) ) * dxPlanet
    fNety += ( bigG * player.mass / (dxPlanet ** 2 + dyPlanet ** 2) ) * dyPlanet

    #fNetx -= player.vel[0] * player.constants['constantThrustDrag']
    #fNety -= player.vel[1] * player.constants['constantThrustDrag']
    return fNetx, fNety

def calcPlayerNetTorque(app):
    fNetTheta = 0
    fNetTheta += player.thrust[1]
    fNetTheta -= player.vel[2] * player.constants['constantRollDrag']
    return fNetTheta

def snapVelocitiesToZero():
    if player.thrust[0] == 0:
        if abs(player.vel[0]) < player.constants['minimumLinearSpeed']:
            player.vel[0] = 0
        if abs(player.vel[1]) < player.constants['minimumLinearSpeed']:
            player.vel[1] = 0
    if player.thrust[1] == 0:
        if abs(player.vel[2]) < player.constants['minimumRotationalSpeed']:
            player.vel[2] = 0

# === EVENT HANDLING ===

# STEPPING

def onStep(app):
    takePlayerPhysicsStep(app)
    setRenderOrigin(app) # so it always centers
    stepScale(app)
    
# PLAYER INTERACTION

def onKeyPress(app, key):
    player.thrustKeysPressed(key)
    player.generalKeysPressed(app, key)

def onKeyHold(app, key):
    player.thrustKeysHeld(key)
    player.generalKeysHeld(app, key)

def onKeyRelease(app, key):
    player.thrustKeysReleased()
    player.generalKeysReleased(app, key)

# DRAWING

def redrawAll(app): 
    #greenBallBall.draw(app)
    #greenBallLine.draw(app)

    greenPlanet.draw(app)
    greenPlanet.drawCollider(app)

    Apple.draw(app)
    #drawCircle(*renderCoords(app, app.objectOnePos), 400 * app.scale, fill = 'green')
    #drawLineTopX, drawLineTopY = app.objectOnePos[0], app.objectOnePos[0] + 30
    #drawLine(*renderCoords(app, app.objectOnePos), *renderCoords(app, (drawLineTopX, drawLineTopY)), lineWidth = 2 * app.scale, fill = 'black')

    player.draw(app)
    drawRenderOrigin(app)

    drawLabel(f"Thrust: {player.thrust}", 100, 30, align = 'left')
    xThrust = math.sin(math.radians(player.pos[2]))
    yThrust = math.cos(math.radians(player.pos[2]))
    drawLabel(f"Angle Components: {xThrust}, {yThrust}", 100, 110, align = 'left')

    drawLabel(f"Speed: {player.vel}", 100, 50, align = 'left')
    trueSpeed = hypotenuse(player.vel[0], player.vel[1])
    drawLabel(f"Absolute Speed:{trueSpeed}", 100, 70, align = 'left')

    drawLabel(f"Pos: {player.pos}", 100, 90, align = 'left')

    drawLabel(f"Scale: {app.scale}", 100, 130, align = 'left')

    

# === APP INITIALIZATION ===

def debugGamut(app):
    app.isTheGravityOn = False

def onAppStart(app):
    setRenderOrigin(app)
    setScaleStart(app)

    generateCollisionMeshes()
    # Game state
    app.stepsPerSecond = 30

# === MAIN ===

def main():
    scale = 600
    runApp(width = 600, height = 600)

main()