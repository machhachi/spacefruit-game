# Main.py

# Spacefruit the Game
# Main file
# By Alexander Werth
# Andrew ID: awerth2
# Recitation: U

# Cumulative Hours = about 51, but who's counting?

# <=> Credits, Disclaimers, and Inspiration <=>

# Explicit crediting: I did not create the line-segment intersection I used
# Find it here at https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/
# It serves in a raycasting algorithm, to check the collisions between generated rays and polygon segments in LinePlanet -> getExpandedCollisionData

# Thank you to Michael Taylor for the class, the OH, the time, the thought, and the conversation.
# As of 1am on 7/29/25, your original suggestion for raycast polygon collisions is fully implemented, much to my relief.
# This had better make it in the history books.

# <=> Cool Things that You should Look At <=>

# Check out my MyMath and Vector classes! It's made for some very elegant coding, especially the latter, though some early areas (gravity) predate use of vector methods.

# PLEASE be as impressed by LinePlanets as I am. The collision logic for them was astoundingly hard.
#   - Note that each time a Smallbody runs collision checking on a line planet, it passes in its own radius.
#   - That's because each Line Planet is prepared to generate a collision mesh LIVE, custom such that it'll interact with the centerpoint of the body calling upon it.
#   - The subsequent actual collision checking is fun too: it implements my built-by-hand(almost, see disclaimer) raycasting,
#       and even generates circular colliders at the vertices to handle corners.

# Scroll down to the Render class as well!
#   Rendering was essentially the first major tool I designed, and it now lets me navigate my simulation world like a dream:
#   - All 'world' coordinates are totally fixed,
#   - The player 'camera' can move, rotate, and zoom in/out at will,
#   - And, as mathematics intended, positive Y correlates to upwards on the screen.


# <=> Desires <=>

# Real current projects

# ACHIEVED GENERAL GRAVITY
# ACHIEVED LINE PLANETS
# ACHIEVED DIAGETIC LINE PLANET COLLISIONS
# ACHIEVED MOVING PLANET COLLISIONS
# ACHIEVED PARAMETERIZED ROTATION
# Parameterized orbits
# Transparent sprites
# Preloading images so that they don't lag-spike when first drawn (player flames particularly)
# Fruit spawning, pickup, inventory
# Text particles?



# Fields of investigation

# Line planet collisions are buggier than I recall, particularly around sharp vertices.
#   Maybe they've always been that way. IDK. 
#   Check the ordering of vertex collision vs segment collision. IDK which ordering is ideal - I think segment first is - but not sure.

# Drawing a lineplanet on top of a planet. I think we're ready.
#   Actually, we've been ready with static planets, but now, we can do it with rotation.
#   Make sure the sphere and line planets share a center, then, the rotation method should do the trick.

# Bottom of screen aligns to biggest gravity influence
# You can go into smallbody logic and run code if the current instance is a player.
# Do that, to pump out the list of gravitational pulls (magnitude and direction both needed) to some sort of list attribute
# In render, create a method that makes a weighted average
# and submits the angle to the master rotate


# Physics engine level developments

# Develop a landing mode for player - for it to have a bottom orientation whenever it collides, and for it to then have:
#   - no elasticity
#   - really strong friction
#       - or perhaps some method of engaging in pure corotation with the planet body
#       - This happened in my rotationPath development. Early on, I tried directly setting the player rotation velocity to negative planet rotation velocity
#       - And while it produced the most stable effect, it did prevent the player thrust rotation from really doing anything.
#       - That wasn't going to cut it then, but could that be a desirable result now?

# Entity culling for rendering at certain distance(all things have pos attribute)
# Perhaps entity culling for gravity as well



# Entirely new mechanisms
#   Gravity hand!!!!!
#       A probe spawned at mouse coordinates backtranslated to realspace (oh god we gotta run that calculation in reverse????)
#           That'll be a hell of a black box function
#           And it'll also be relevant, in the scale calculations, to define a furthest distance from the player the thing can be at
#       Probe, when mouse is being held, exerts a strong gravity on, i guess, all non-player smallbodies



# HUD elemtents needed:
#   Boost meter
#   Strongest gravity influence
#   Velocity


# === IMPORTS ===

from cmu_graphics import *
import math

# === CLASSES: FUNCTION LIBRARIES ===

class MyMath():
    def __init__(self):
        pass

    def sign(self, x):
        return 1 if x >= 0 else -1
    
    def hypotenuse(self, a, b):
        return (a ** 2 + b ** 2) ** 0.5
    
    def distance(self, x1, y1, x2, y2):
        return self.hypotenuse(x2 - x1, y2 - y1)
    
    def heronArea(self, a, b, c):
        s = (a + b + c) / 2
        return ( ( s * (s - a) * (s - b) * (s - c) ) ** 0.5 )
    
mymath = MyMath()

class Vector(): # A package of vector functions
    def __init__(self):
        pass

    def vectorize(self, line): # Line (coords) to vector
        return (line[1][0] - line[0][0], line[1][1] - line[0][1])

    def distance(self, v1, v2):
        dx = v2[0] - v1[0]
        dy = v2[1] - v1[1]
        return mymath.hypotenuse(dx, dy)
    
    def len(self, v):
        return mymath.hypotenuse(v[0], v[1])
    
    def add(self, v1, v2):
        return (v1[0] + v2[0], v1[1] + v2[1])
    
    def subtract(self, v1, v2):
        return (v1[0] - v2[0], v1[1] - v2[1])
    
    def scale(self, v, k):
        return (v[0] * k, v[1] * k)
    
    def unit(self, v): # With non-div0 insurance ( I can't believe that didn't come up until now! )
        return (0, 0) if self.len(v) == 0 else ( v[0] / self.len(v), v[1] / self.len(v) )
    
    def dot(self, v1, v2):
        return v1[0] * v2[0] + v1[1] * v2[1] # startlingly simple
    
    def cw(self, v):
        return (v[1], -v[0])
    
    def ccw(self, v):
        return (-v[1], v[0])
    
    def heronAreaByPoints(self, pointP, pointQ, pointR):
        lineA, lineB, lineC = vector.distance(pointP, pointQ), vector.distance(pointQ, pointR), vector.distance(pointR, pointP)
        return mymath.heronArea(lineA, lineB, lineC)
    
    def add2to3(self, v3, v2):
        return(v3[0] + v2[0], v3[1] + v2[1], v3[2])
    
    def rotate(self, v, theta):
            inputX = v[0]
            inputY = v[1]
            theta = math.radians(theta)
            rotatedX = math.cos(theta) * inputX - math.sin(theta) * inputY
            rotatedY = math.sin(theta) * inputX + math.cos(theta) * inputY
            return (rotatedX, rotatedY)
    
vector = Vector()

class Motion(): # Specific handlers for my motion (mostly conversion from tuples to lists)
    def __init__(self):
        pass

    # Mutating component addition
    def plusEq(self, thing1, thing2, ignoreThirdComponent = False):
        # componentwise list modification. Designed to function whether or not second list / tuple has a third component (but always expects first to have one)
        thing1[0] += thing2[0]
        thing1[1] += thing2[1]
        if not ignoreThirdComponent and len(thing2) == 3:
            thing1[2] += thing2[2]

    # Non-mutating component addition
    def getSum(self, thing1, thing2, ignoreThirdComponent = False):
        # Componentwise list modification
        compX = thing1[0] + thing2[0]
        compY = thing1[1] + thing2[1]
        compR = thing1[2] + thing2[2] if ( not ignoreThirdComponent and len(thing2) == 3 ) else thing1[2]
        return [compX, compY, compR]

    def invert(self, thing1):
        return [comp * -1 for comp in thing1]

motion = Motion()

# === CLASSES: DEBUG DRAWN OBJECTS ===

# A drawn object
class Helperball():
    Instances = []
    def __init__(self, centerPos, size, color = 'black'):
        self.centerPos = centerPos
        self.size = size
        self.color = color

        Helperball.Instances.append(self)
    
    def draw(self, app):
        drawCircle(*render.getCoords(self.centerPos), render.getScale(self.size), fill = self.color)

class Helperline():
    Instances = []
    def __init__(self, startPos, endPos, thickness, color = 'black'):
        self.startPos = startPos
        self.endPos = endPos
        self.color = color
        self.thickness = thickness

        Helperline.Instances.append(self)

    def setPos(self, startPos, endPos):
        self.startPos = startPos
        self.endPos = endPos
    
    def draw(self, app):
        drawLine(*render.getCoords(self.startPos), *render.getCoords(self.endPos), lineWidth = render.getScale(self.thickness), fill = self.color)

# === CLASSES: SIMULATION SUPPORT ===

# === CLASSES: GAME OBJECTS ===

# SmallBodies: A small object that collides with planets
class SmallBody():
    Instances = []

    def __init__(self, pos, vel, size, mass):
        self.pos = pos
        self.vel = vel
        self.size = size
        self.mass = mass

        SmallBody.Instances.append(self)

        self.constants = {
            'minimumLinearSpeed': 0,
            'minimumRotationalSpeed': 0,
            'constantThrustDrag': 0,
            'constantRollDrag': 0
        }

        self.collisionConstants = {
            'elasticity':0.5,
            'friction':0.7
        }

    # Physics 
    def takePhysicsStep(self, app):
        # Force
        fNetx, fNety = self.calcNetForce(app)
        fNetTheta = self.calcNetTorque()

        # Acceleration, velocity, position
        ddx = fNetx / self.mass
        ddy = fNety / self.mass
        ddTheta = fNetTheta / self.mass

        self.vel[0] += ddx
        self.vel[1] += ddy
        self.vel[2] += ddTheta

        self.applyDrag()
        self.snapVelocitiesToZero()
        
        self.pos[0] += self.vel[0]
        self.pos[1] += self.vel[1]
        self.pos[2] += self.vel[2]

    def calcNetForce(self, app):
        fNetx, fNety = 0, 0

        fGx, fGy = self.getAllPlanetGravity(app)

        fNetx += fGx
        fNety += fGy
        return fNetx, fNety

    def getAllPlanetGravity(self, app):
        fGx, fGy = 0, 0
        for thisPlanet in Planet.Instances:
            # Get distance vector to planet
            dxPlanet, dyPlanet = thisPlanet.pos[0] - self.pos[0], thisPlanet.pos[1] - self.pos[1]
            # Crunch newtonian gravity: gmM / r^2
            fGThisPlanet = ( app.bigG * self.mass * thisPlanet.mass ) / (dxPlanet ** 2 + dyPlanet ** 2)
    
            xHat, yHat = vector.unit((dxPlanet, dyPlanet))
            fGx += fGThisPlanet * xHat
            fGy += fGThisPlanet * yHat
        return fGx, fGy

    def calcNetTorque(self): # Placeholder for player
        return 0

    def applyDrag(self):
        self.vel[0] -= self.vel[0] * self.constants['constantThrustDrag'] / self.mass
        self.vel[1] -= self.vel[1] * self.constants['constantThrustDrag'] / self.mass
        self.vel[2] -= self.vel[2] * self.constants['constantRollDrag'] / self.mass

    def snapVelocitiesToZero(self):
        if abs(self.vel[0]) < self.constants['minimumLinearSpeed']:
            self.vel[0] = 0
        if abs(self.vel[1]) < self.constants['minimumLinearSpeed']:
            self.vel[1] = 0
        if abs(self.vel[2]) < self.constants['minimumRotationalSpeed']:
            self.vel[2] = 0

    # Collision
    def collide(self):
        self.collideWithSpheres()
        self.collideWithLines()
        self.collideWithSmallbodies()

    def collideWithSpheres(self):
        for thisPlanet in SpherePlanet.Instances:
            # Test if we are within the collision circle, thus, colliding with the body
            if vector.distance(self.pos, thisPlanet.pos) <= self.size + thisPlanet.size:
                normal = thisPlanet.getNormalVectorTo(self.pos) # unit normal vector
                depth = vector.distance(self.pos, thisPlanet.pos) - (self.size + thisPlanet.size)

                self.moveWithRotatingPlanet(thisPlanet)
                self.evaluatePlanetCollision(thisPlanet, normal, depth)
                
    def collideWithLines(self):
        for thisPlanet in LinePlanet.Instances:
            # Don't bother calculating unless we're in the relevant range to begin
            if vector.distance(self.pos, thisPlanet.pos) <= thisPlanet.getCollisionCheckRadius():
                # Use dedicated lineplanet collision method, which takes a size, as to generate a specific collision mesh that interacts with this smallbody's radius
                collisionResult = thisPlanet.getExpandedCollisionData(self.pos, self.size)
                if collisionResult != False:
                    normal, trueDepth = collisionResult

                    self.moveWithRotatingPlanet(thisPlanet)
                    self.evaluatePlanetCollision(thisPlanet, normal, trueDepth)

    def collideWithSmallbodies(self):
        pass  
    
    def moveWithRotatingPlanet(self, collidingPlanet):
        assert(isinstance(collidingPlanet, Planet))
        
        planetPos, planetVel = collidingPlanet.getPosVelData()  
        if planetVel[2] != 0: # If planet is rotating!!!:
            # Just rotate along the position vector relative to planet center
            smallBodyRelPos = vector.subtract(self.pos, planetPos)
            rotatedRelPos = vector.rotate(smallBodyRelPos, planetVel[2])
            
            linearMovementMade = vector.subtract(rotatedRelPos, smallBodyRelPos) # The distance to travel
            rotationChanged = -planetVel[2] # The body should corotate with a rotating body it sits on
            dPosition = list(linearMovementMade) + [rotationChanged] # Format to 3-len list

            motion.plusEq(self.pos, dPosition) # Single mutation should do it

    def evaluatePlanetCollision(self, collidingPlanet, normal, depth):
        assert(isinstance(collidingPlanet, Planet))

        def stripPlanetMotion(velocity, thisPlanet):
            planetPos, planetVel = thisPlanet.getPosVelData()
            return motion.getSum(velocity, motion.invert(planetVel))

        def injectPlanetMotion(velocity, thisPlanet):
            planetPos, planetVel = thisPlanet.getPosVelData()
            return motion.getSum(velocity, planetVel)
        
        relativeVelocity = stripPlanetMotion(self.vel, collidingPlanet)

        normalX, normalY = normal[0], normal[1]

        vRadial = vector.dot(relativeVelocity, normal) # magnitude velocity in direction of planet center
        vXRadial, vYRadial = normalX * vRadial, normalY * vRadial # components thereof

        # Evaluate collision if we're moving inwards towards planet

        if vector.dot(normal, (vXRadial, vYRadial)) < 0: # Negative -> misaligned -> moving inwards towards planet
            # (Note: if you were to check position interiority and not velocity, then you might repeat this collision)
            # (That would be rubber-banding, where you get insane collisions because one phys step isn't enough to un-collide you)
            # (This way, any collision will only have 1 velocity change before the object stops going inwards)

            # Position adjustment
            #   Depth, or Altitude when positive, (inward-surface-to-surface dist), is negative since we are within collision bounds
            #   So subtract it out of position to push smallbody to the exact bound
            self.pos[0] -= depth * normalX
            self.pos[1] -= depth * normalY

            # Velocity adjustment
            #   First, extract radial and tangential velocity
            vXTangential = relativeVelocity[0] - vXRadial
            vYTangential = relativeVelocity[1] - vYRadial

            # Radial component: "bounce" speed. Output should be 0x original (inelastic) up to -1x(elastic)
            newVXRadial = -vXRadial * self.collisionConstants['elasticity']
            newVYRadial = -vYRadial * self.collisionConstants['elasticity']

            # Tangential component: "skid" speed. Multiply by some decreasing fraction, and convert some to rolling.
            newVXTangential = vXTangential * (1 - self.collisionConstants['friction'])
            newVYTangential = vYTangential * (1 - self.collisionConstants['friction'])

            # Roll component: rolling. Whatever was lost in tangential, we assume it goes about fully into rolling.
            #   To get the direction: we need to know if we're moving CW or CCW about the planet 
            #   If you rotate the normal vector (points outwards) 90 degrees CW, that now points in the CW-about-planet direction
            #   And we can use dot product to see if we're aligned or unaligned with that

            # Vector transformation for rotating CW 90 degrees
            surfaceTangentX, surfaceTangentY = normalY, -normalX
            rollVelocity = vector.dot((vXTangential, vYTangential), (surfaceTangentX, surfaceTangentY)) * self.collisionConstants['friction']

            # Convert linear to angular by diving by radius
            rollConversionFactor = 10 / self.size # step count
            
            # Decreasing old angular velocity is a crack solution to the rolling-amplification issue I had a bit ago
            oldRollCarryover = relativeVelocity[2] * 0.95
            newVTheta = oldRollCarryover + rollVelocity * rollConversionFactor

            # Recombine 

            recombinedVel = [
                newVXRadial + newVXTangential,
                newVYRadial + newVYTangential,
                newVTheta
            ]

            self.vel = injectPlanetMotion(recombinedVel, collidingPlanet)

    

    # Rendering
    def draw(self, app):
        drawCircle(*render.getCoords(self.pos), render.getScale(self.size), fill = 'black')
        drawStar(*render.getCoords(self.pos), render.getScale(self.size), 5, fill = 'white', rotateAngle = render.getAngle(self.pos[2]))

    # Step
    def step(self, app):
        self.collide()
        self.takePhysicsStep(app)

class Player(SmallBody):
    def __init__(self, pos, vel, size, mass):
        super().__init__(pos, vel, size, mass)
        self.thrust = [0, 0]

        self.boostMeter = 100
        self.boostMax = 100
        self.boostRefillRate = 1

        self.landing = False
        
        self.thrustSpriteIndex = 0

        self.thrustConstants = {
            'thrustForce': 5,
            'rollForce': 2,
            'boostMult': 2
        }

        self.constants = {
            'minimumLinearSpeed': 0.001,
            'minimumRotationalSpeed': 0.005,
            'constantThrustDrag': 0.02,
            'constantRollDrag': 0.1
        }
  
    # Key inputs
    def thrustKeysPressed(self, key):
        if key in {'w', 'a', 's', 'd'}:
            player.thrust = [
                ( int(key == 'w') - int(key == 's') ) * self.thrustConstants['thrustForce'],
                ( int(key == 'd') - int(key == 'a') ) * self.thrustConstants['rollForce']
            ]

    def thrustKeysHeld(self, keyList):
        setKeys = set(keyList)
        if setKeys.intersection({'w', 'a', 's', 'd'}) != set(): # Non-empty intersection, so at least 1 is held
            player.thrust = [
                ( int('w' in setKeys) - int('s' in setKeys) ) * self.thrustConstants['thrustForce'],
                ( int('d' in setKeys) - int('a' in setKeys) ) * self.thrustConstants['rollForce']
            ]
            player.thrustSpriteIndex = (player.thrustSpriteIndex + 1) % 4
    
    def thrustKeysReleased(self):
        player.thrust = [0, 0]

    def generalKeysPressed(self, app, key):
        pass
    
    def generalKeysHeld(self, app, keyList):
        render.scaleChangeDirection = int('up' in keyList) - int('down' in keyList)

    def generalKeysReleased(self, app, key):
        render.scaleChangeDirection = 0
    
    # Boost thrust
    def getBoost(self):
        return self.boostMeter

    def stepBoost(self):
        if self.thrust[0] != 0 and self.boostMeter > 0:
            boostThrust = self.thrustConstants['thrustForce'] * self.thrustConstants['boostMult'] 
            self.thrust[0] = mymath.sign(self.thrust[0]) * boostThrust
            self.boostMeter -= 1
        elif self.thrust[0] == 0 and self.boostMeter < self.boostMax:
            self.boostMeter += self.boostRefillRate
        #print(self.boostMeter)

    # Modified physics methods
    def calcNetForce(self, app): # Includes player thrust
        # Force
        fNetx, fNety = 0, 0 

        # Player input
        fNetx += self.thrust[0] * math.sin(math.radians(self.pos[2]))
        fNety += self.thrust[0] * math.cos(math.radians(self.pos[2]))

        # Gravity
        # Gravity method is the same for small bodies as is for player
        fGx, fGy = self.getAllPlanetGravity(app)
        fNetx += fGx
        fNety += fGy

        return fNetx, fNety

    def calcNetTorque(self): # Includes player thrust
        fNetTheta = 0
        fNetTheta += self.thrust[1]
        return fNetTheta
    
    def snapVelocitiesToZero(self): # Only invokes if player not thrusting
        if self.thrust[0] == 0:
            if abs(self.vel[0]) < self.constants['minimumLinearSpeed']:
                self.vel[0] = 0
            if abs(self.vel[1]) < self.constants['minimumLinearSpeed']:
                self.vel[1] = 0
        if self.thrust[1] == 0:
            if abs(self.vel[2]) < self.constants['minimumRotationalSpeed']:
                self.vel[2] = 0

    # Stepping:
    def step(self, app):
        self.stepBoost()
        self.collide()
        self.takePhysicsStep(app)
    
    # Rendering
    
    def getFlamesThatShouldBeDrawn(self):
        # Returns one list based on whether or not to display the rocket flames
        result = []
        if self.thrust[1] < 0: # If turning left, display right thruster
            result.append('right')
        if self.thrust[1] > 0: # If turning right, left thruster
            result.append('left')
        if self.thrust[0] != 0: # If moving forward, whatever, run the main
            result.append('main')
        print(result)
        return result

    def draw(self, app):
        mainSprite = "assets/player/player_base.png"

        rawWidth, rawHeight = getImageSize(mainSprite) # ought to be 500 x 500
        playerScaleFactor = 0.0293 # 60 / 2048
        realWidth, realHeight = render.getScale(rawWidth * playerScaleFactor), render.getScale(rawHeight * playerScaleFactor)

        # Drawing possible thrust directions
        if player.thrust != [0, 0]: # Cull for processing speed
            for direction in self.getFlamesThatShouldBeDrawn(): # One string for each thruster
                flameSprite = f"assets/player/player_flame_{direction}_{self.thrustSpriteIndex + 1}.png"
                drawImage(flameSprite,
                        *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                        width = realWidth * 2, height = realHeight * 2, align = 'center')
                
        # Drawing player

        drawImage(mainSprite, 
                  *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                  width = realWidth, height = realHeight, align = 'center')
        
        # Drawing two types of landing legs

        #landingCondition = 'open' if self.landing else 'closed'
        #landingSprite = f"assets/player/player_landing_{landingCondition}.png"

        #drawImage(landingSprite, 
        #          *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
        #          width = realWidth, height = realHeight, align = 'center')
    
    def draw(self, app):

        drawCircle(*render.getCoords(self.pos), render.getScale(self.size * 2))

        debugMainSprite = "assets/TRANSPARENCY TEST SHUTTLE-01.png"

        rawWidth, rawHeight = getImageSize(debugMainSprite) # ought to be 500 x 500
        playerScaleFactor = 0.03 # 3 / 25, the pixel ratio from 500x500 sprite to 60x60 game natural size
        realWidth, realHeight = render.getScale(rawWidth * playerScaleFactor), render.getScale(rawHeight * playerScaleFactor)

        drawImage(debugMainSprite, 
                  *render.getCoords(self.pos), rotateAngle = render.getAngle(self.pos), 
                  width = realWidth, height = realHeight, align = 'center')
  
class Fruit(SmallBody):
    def __init__(self, pos, vel, type, customSize = None, customMass = None):
        super().__init__(pos, vel)
        
        typeDict = {
            'debug':{
                'Name':'Debug Fruit',
                'Size':20,
                'Mass':30,
                'Image':['Circle','orchid'],
                'Flavortext':'Testing flavortext'
            },
            'apple':{
                'Name':'Red Delicious',
                'Size':15,
                'Mass':30,
                'Image':['Sprite','fake apple url here'],
                'Flavortext':"The shittiest of them all. We're taking points away from you, just for having this."
            },
            'jackfruit':{
                'Name':'Gravitational Jackfruit',
                'Size':80,
                'Mass':100,
                'Image':['Sprite','evil jackfriut url here'],
                'Flavortext':"The grand daddy. This thing will wipe out stars, if you're not careful."
            },
            'whitepeach':{
                'Name':'Starlight Peach',
                'Size':25,
                'Mass':25,
                'Image':['Sprite','fake peach url here'],
                'Flavortext':"So light it nearly floats. You could lose this one, among all the stars."
            },
            'cherry':{
                'Name':'Space Debris Cherry',
                'Size':5,
                'Mass':5,
                'Image':['Sprite','wrong cherry url here'],
                'Flavortext':"Small and sweet. The pit appears to be, somehow, a piece of a satellite."
            },
        }
        
        thisFruitType = typeDict[type]
        self.name = thisFruitType['Name']
        self.size = thisFruitType['Size'] if customSize == None else customSize
        self.mass = thisFruitType['Mass'] if customMass == None else customMass

player = Player([-30, -1000, 0], [0, 1, 0], 30, 50)

# Planets: A big object that can move around in the world
class Planet():
    Instances = []
    def __init__(self, pos, vel, mass):
        self.pos = pos
        self.vel = vel
        self.mass = mass

        # Set default angle if undefined
        if len(self.pos) < 3:
            self.pos = [ self.pos[0], self.pos[1], 0 ]
        if len(self.vel) < 3:
            self.vel = [ self.vel[0], self.vel[1], 0 ]

        Planet.Instances.append(self)
    
    def __repr__(self):
        return f"Planet, default (s={self.pos}, v={self.vel}, m={self.mass})"
    
    def step(self):
        motion.plusEq(self.pos, self.vel)
        pass # As per (ideal) implementation of orbit paths, planets do not handle their own motion. They are perfectly parameterized, not simulated

    def getPosVelData(self):
        return self.pos, self.vel
    
    def setPos(self, newpos):
        self.pos = newpos
    
    def setVel(self, newvel):
        self.vel = newvel

class SpherePlanet(Planet):
    Instances = []
    def __init__(self, pos, vel, size, mass, color):
        super().__init__(pos, vel, mass)
        # Calling super_init has the added benefit of appending it to the superclass's instance list
        # So this sphereplanet is ALSO contained in the list of general
        self.size = size
        self.color = color

        SpherePlanet.Instances.append(self)

    def __repr__(self):
        return f"Planet, sphere (s={self.pos}, v={self.vel}, m={self.mass}, r={self.size})"
        
    def getNormalVectorTo(self, otherpos):
        xComp = otherpos[0] - self.pos[0]
        yComp = otherpos[1] - self.pos[1]
        return vector.unit((xComp, yComp))

    # Rendering
    def draw(self, app):
        drawCircle(*render.getCoords(self.pos), 
                    render.getScale(self.size), 
                    rotateAngle = render.getAngle(self.pos),
                    fill = self.color)

class LinePlanet(Planet):
    Instances = []
    def __init__(self, centerPos, vel, mass, mesh):
        super().__init__(centerPos, vel, mass)
        # Wind the mesh counterclockwise
        # All hell will break loose if this mesh isn't wound counterclockwise
        # I swear to god
        self.mesh = mesh
        self.setCollisionCheckRadius()

        LinePlanet.Instances.append(self)

    def __repr__(self):
        return f"Planet, line (s={self.pos}, v={self.vel}, m={self.mass})"

    # Mesh Helping
    def getWorldspaceMesh(self):
        rotatedOffsets = [
            vector.rotate(thisPoint, self.pos[2])
                for thisPoint in self.mesh
        ]
        return [
            (thisPoint[0] + self.pos[0], 
             thisPoint[1] + self.pos[1]) 
                for thisPoint in rotatedOffsets
        ]
    
    def getLinesFromPoints(self, points):
        # Takes list of size-2 tuples, makes list of size-2 with nested size-2 tuples
        result = []
        for i in range(len(points)):
            # BEGINS by winding last to first
            # then proceeds up the list
            result.append(
                (
                    (points[i-1][0], points[i-1][1]),
                    (points[i][0], points[i][1])
                )
            )
        return result # List of lines, each a 2-length tuple, containing 2 points, each 2-length tuples

    def getWorldMeshLines(self):
        return self.getLinesFromPoints(self.getWorldspaceMesh())
    
    # Collision

    # Calculate and save collision radius
    def setCollisionCheckRadius(self):
        furthestPointDistance = 0
        furthestPoint = None
        for relativePoint in self.mesh:
            # Get radial distance from defined center
            currentDistance = vector.len(relativePoint)
            
            # Set to first, or to furthest away
            if furthestPoint == None or currentDistance > furthestPointDistance:
                furthestPoint = relativePoint
                furthestPointDistance = currentDistance
        # We got the furthest point
        self.collisionCheckRadius = furthestPointDistance

    def getCollisionCheckRadius(self):
        return self.collisionCheckRadius
    
    # Generate, live, expanded meshes depending on provided distance change (radius of colliding smallbody, eventually)
    def generateExpandedLinearMesh(self, d):
        originalLines = self.getWorldMeshLines()

        expandedSegmentMesh = []
        for segment in originalLines:
            lineVector = vector.vectorize(segment)
            normal = vector.unit(vector.cw(lineVector))
            shift = vector.scale(normal, d) # We move along normal vector by d

            newStartPoint = vector.add(segment[0], shift) # The shift is a delta, so this translates the segment points by shift (yay!)
            newEndPoint = vector.add(segment[1], shift)
            expandedSegmentMesh.append((newStartPoint, newEndPoint))
        return expandedSegmentMesh
    
    def generateExpandedCornerMesh(self, d):
        originalLines = self.getWorldMeshLines()

        convexVertices = [] # Name is vestigial. Don't need to avoid putting these in concavities.
        for pointIndex in range(len(originalLines)):
            firstSegment = originalLines[pointIndex - 1] # If the first pair is (-1) and (0), we've successfully wound without exceeding loop indices
            secondSegment = originalLines[pointIndex]

            assert( firstSegment[1] == secondSegment[0] ) # Just gonna leave this here for debugging purposes. These should all be wound such that they have common points
            thisVertex = secondSegment[0] # equivalently, firstSegment[1]
            
            convexVertices.append(thisVertex) # It actually improves sim to have circles in the concavities too. No distinction made between convex and concave
        return convexVertices # Since we know d the entire time, we crunch the numbers on circle intersection outside of this function. Theoretically, it's distance-agnostic.
    
    # Check interiority with internal new mesh generation
    def getExpandedCollisionData(self, testPoint, expandRadius):

        # === # === # === # === #
        # LINEAR MESH COLLIDER
        # === # === # === # === #
        
        # Welcome to hell. This single function, and its connections upstairs in collideWithLines, made for easily ten straight hours of development on Monday, July 28th, 2025.
        # But in all fairness, this is sick as fuck.
        # Circle collisions, of ANY radius, with an arbitrary polygon? Gorgeous.

        # === # === # === # === #
        # PART 1: COLLIDING WITH LINEAR SEGMENTS OF THE EXPOSED MESH
        # === # === # === # === #

        expandedMesh = self.generateExpandedLinearMesh(expandRadius)

        # To dodge any edge cases, we calc interiority by majority vote
        interiorityConsensus = 0

        # Raycast segment generation ( 8 cardinal directions seems to suffice )
        raycastSegments = []
        unitDirections = [(1, 0), (0, 1), (-1, 0), (0, -1), # Eight cardinal directions
                          (0.7, 0.7), (-0.7, 0.7), (-0.7, -0.7), (0.7, -0.7)] # In idgaf terms, sqrt(2)/2 = 0.7
        maxRayLength = self.getCollisionCheckRadius() * 2 # Collision *diameter* means we are guaranteed to cross the entire circle, thus the entire mesh
        rayStart = testPoint
        for rayIndex in range(8):
            # Each endpoint is the respective cardinal unit direction scaled by the max possible radius we'd need to check
            # and of course it needs to be made relative to start, hence vector.add()
            rayEnd = vector.add(rayStart, vector.scale(unitDirections[rayIndex], maxRayLength))
            raycastSegments.append((rayStart, rayEnd))
        
        # Collision counting
        for ray in raycastSegments:
            intersectionCount = 0
            for segment in expandedMesh:
                doesIntersect = self.segmentsIntersect(ray, segment)
                if doesIntersect != False:
                    intersectionCount += 1
                    # Any business about getting the closest intersection
            hasOddIntersections = intersectionCount % 2 == 1
            interiorityConsensus += 1 if hasOddIntersections else -1
        
        # We've collided with lines.
        if interiorityConsensus > 0:
            # Return the closest segment as determined by smallest area via Heron's Formula
            minArea = None
            closestSegment = None
            for segment in expandedMesh:
                area = vector.heronAreaByPoints(*segment, testPoint)
                if minArea == None or area < minArea:
                    closestSegment = segment
                    minArea = area
            
            def segmentToCollisionData(segment):
                # Rotate the (vectorized)segment to get its normal vector
                normal = vector.unit(vector.cw(vector.vectorize(segment)))
                # Via triangle angle formula (A = 1/2 bh), get h = 2 * area / base
                absDepth = 2 * vector.heronAreaByPoints(segment[0], segment[1], testPoint) / vector.len(vector.vectorize(segment))
                return normal, -absDepth # depth should be negative

            return segmentToCollisionData(closestSegment)
        
        # === # === # === # === #
        # PART 2: COLLIDING WITH ROUNDED VERTICES OF THE EXPANDED MESH
        # === # === # === # === #

        expansionVertices = self.generateExpandedCornerMesh(expandRadius)

        for testVertex in expansionVertices:
            if vector.distance(testVertex, testPoint) <= expandRadius: # Colliding with this circle:
                normal = vector.unit(vector.subtract(testPoint, testVertex))
                depth = vector.distance(testVertex, testPoint) - expandRadius # should be negative
                return normal, depth
        
        # Goddamn it. It really puts things into perspective when you can spend ten hours developing a line collider and six lines rewriting a circle one

        return False
            
    def segmentsIntersect(self, line1, line2):
        # Full credit to https://www.geeksforgeeks.org/dsa/check-if-two-given-line-segments-intersect/
        # It's a nice one

        def onSegment(p, q, r):
            return ( q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and
                     q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))
        
        def winding(p, q, r):
            val = ( (q[1] - p[1]) * (r[0] - q[0]) -
                    (q[0] - p[0]) * (r[1] - q[1]) )

            # collinear
            if val == 0:
                return 0
            # 1 for clockwise, 2 for counterclockwise
            return 1 if val > 0 else 2

        # Calculate four windings of subsets of the points (a segment and one end of the other)
        o1 = winding(line1[0], line1[1], line2[0])
        o2 = winding(line1[0], line1[1], line2[1])
        o3 = winding(line2[0], line2[1], line1[0])
        o4 = winding(line2[0], line2[1], line1[1])

        # general case
        if o1 != o2 and o3 != o4:
            return True
        
        # special cases
        # p1, q1 and p2 are collinear and p2 lies on segment p1q1
        if o1 == 0 and onSegment(line1[0], line2[0], line1[1]):
            return True

        # p1, q1 and q2 are collinear and q2 lies on segment p1q1
        if o2 == 0 and onSegment(line1[0], line2[1], line1[1]):
            return True

        # p2, q2 and p1 are collinear and p1 lies on segment p2q2
        if o3 == 0 and onSegment(line2[0], line1[0], line2[1]):
            return True

        # p2, q2 and q1 are collinear and q1 lies on segment p2q2 
        if o4 == 0 and onSegment(line2[0], line1[1], line2[1]):
            return True
        
        return False

    # Rendering
    def draw(self, app):
        for thisLine in self.getLinesFromPoints(self.getWorldspaceMesh()):
            lineStart = render.getCoords(thisLine[0])
            lineEnd = render.getCoords(thisLine[1])
            drawLine(*lineStart, *lineEnd, fill = 'red', lineWidth = render.getScale(2))

# === CLASSES: MOVEMENT CONTROLLERS ===

class OrbitPath():
    Instances = []
    def __init__(self, adoptedPlanet):
        assert(isinstance(adoptedPlanet, Planet))
        self.pathedPlanet = adoptedPlanet

        self.positionAlongPath = 0 # Increases evenly up to (2pi?)
        
        self.initialAngle = 0

        OrbitPath.Instances.append(self)


    @staticmethod
    def globalInitializePosition(planetToInitialize, pos = [0, 0, 0]):
        planetToInitialize.setPos(pos)
        planetToInitialize.setVel([0, 0, 0])
    
    def defineOrbit(self, orbitCenter, radius, speed): # speed roughly in degrees per second
        assert(isinstance(orbitCenter, Planet) or isinstance(orbitCenter, tuple) or isinstance(orbitCenter(list)))
        if isinstance(orbitCenter, Planet):
            self.orbitCenterPos = orbitCenter.pos # Hopefully we can directly alias these together
            self.orbitCenterVel = orbitCenter.vel # DO NOT MODIFY THIS DIRECTLY AS TO NOT BREAK ALIASING. DON'T FUCKING DO IT
        else:
            self.orbitCenterPos = orbitCenter[:2] # If a provided tuple or list. Centerbody-rotation agnostic. Both, awesomely, can be sliced
            self.orbitCenterVel = [0, 0]

        self.orbitRadius = radius

        speedInDegreesPerStep = speed / 30
        self.thetaStep = math.radians(speedInDegreesPerStep)

    @staticmethod
    def initalize():
        for thisOrbit in OrbitPath.Instances:
            thisOrbit.initalizeOrbitposition()

    def initializeOrbitPosition(self, startAngle = 0):
        pass
        
    def getPosAlongOrbit(self, trajectoryPoint):
        return 
    
    def step(self):
        stepSize = self.thetaStep
        pass

class RotatingPath():
    Instances = []
    def __init__(self, adoptedPlanet):
        assert(isinstance(adoptedPlanet, Planet))
        self.pathedPlanet = adoptedPlanet

        self.rotationT = 0
        self.maxT = 360
        # In this system, rotationT corresponds 1-1 from path theta to planet rotation

        RotatingPath.Instances.append(self)
    
    # Object definition
    
    def defineRotation(self, degreesPerSecond, initialTheta = 0): # Called in object definition
        degreesPerTick = degreesPerSecond / 30

        self.rotationT = initialTheta
        self.speed = degreesPerTick

    # App initialization

    @staticmethod
    def initalize():
        for thisRotation in RotatingPath.Instances:
            thisRotation.initializeRotation()
    
    
    def initializeRotation(self): # Called on app start
        self.pathedPlanet.pos[2] = self.rotationT
    
    def step(self):
        # Calculate where the planet should be, and then plug it straight in
        self.rotationT = (self.rotationT + self.speed) % self.maxT
        self.pathedPlanet.pos[2] = self.rotationT
        self.pathedPlanet.vel[2] = self.speed





# === GAME OBJECT INSTANCING ===

# ALL (CORE) POSITION & VELOCITY VECTORS ARE ARE LISTS NOW
# WE LOVE MUTABILITY
# frankly there should be an additional kind of data type, with a set number of slots but is perfectly able to change data within them

#appleBall = SmallBody([-30, 20, 0], [0, 0, 0], 25, 40)

#greenPlanet = SpherePlanet([600, 200], [0, 0], 300, 1000, 'green')
#greenHead = Helperball([500, 500], 30)

#Apple = SpherePlanet( [100, -100], [0, 0], 100, 200, 'red')
#Orange = SpherePlanet([300, -500], [1, -1], 250, 5000, 'orange')

# Polygon points are not stored in lists, they remain tuples. These describe relative positions to the centerpoint, and as such, do not change.
Quadrangle = LinePlanet([-300, -500, 180], [0, 0], 100, [(0, 100), (-100, -100), (100, -200), (150, 100), (100, 400), (-300, 300)])

posHelperLine1 = Helperline([0, 0], [0, 0], 5, 'green')
posHelperLine2 = Helperline([0, 0], [0, 0], 5, 'orchid')


#steelOrchard = SpherePlanet([1000, -1000], [0, 0], 750, 10000, 'forestGreen')


centerOfTheUniverse = Helperball([0, 0], 50, 'black')

# === PATH INSTANCING ===

# First and solidly first: for every planet relevant to the orbiting system, call globalInitializePosition
#OrbitPath.globalInitializePosition(Apple)
OrbitPath.globalInitializePosition(Quadrangle)

# Then, define an appropriate path object for each planet you desire.
# Follow that with the appropriate define method, which specifies relevant characteristics to the path
#appleSpinner = RotatingPath(Apple)
#appleSpinner.defineRotation(30, 0)

quadSpinner = RotatingPath(Quadrangle)
quadSpinner.defineRotation(10, 20)

# === CLASSES: RENDERING ===

class Render():
    # FUNDAMENTALS
    def __init__(self, app):
        self.renderOrigin = (app.width * 0.5, app.height * 0.5)
        self.scale = 1
        self.scaleChangeDirection = 0
        self.setRenderOrigin(app)
    
    def step(self, app):
        self.setRenderOrigin(app)
        self.stepScale()

    def draw(self, app):
        self.internal_drawRenderOrigin(app)
    
    # SCREEN ORIGIN
    def setRenderOrigin(self, app, posX = 0.5, posY = 0.5):
        self.renderOrigin = (app.width * posX, app.height * posY)

    def internal_drawRenderOrigin(self, app):
        drawCircle(*self.renderOrigin, 3 * self.scale, fill = 'black')

    # MASTER RENDERING
    # Master renderer, spits out coordinates shifted by player's position, rotation, screen scale, and screen position
    def getCoords(self, posTuple):
        xReal, yReal = posTuple[0], posTuple[1]
        if len(posTuple) == 3: # I want it to accept both coord and coord + rotation
            thetaReal = posTuple[2]
        else:
            thetaReal = None

        xCam, yCam = player.pos[0], player.pos[1]
        thetaCam = player.pos[2]
        
        # Shift the coordinates in realspace to put the camera at origin, scale all as well
        tx, ty = self.internal_renderTranslate(xReal, yReal, xCam, yCam)
        rx, ry = self.internal_renderRotate(tx, ty, thetaCam)
        finalx, finaly = self.internal_renderScale(rx, ry)
        
        # Shift to render scheme
        return self.internal_renderScreenshift(finalx, finaly)

    # Rotation handler for non-point objects (CMU graphics bodies, images)
    def getAngle(self, rotationCoord): 
        trueBodyAngle = rotationCoord[2] if isinstance(rotationCoord, tuple) or isinstance(rotationCoord, list) else rotationCoord
        return trueBodyAngle - player.pos[2]
    
    # Scale handler for non-point objects
    def getScale(self, normalScale):
        return normalScale * self.scale

    # MASTER RENDER HELPERS 
    # Translation helper
    def internal_renderTranslate(self, x, y, cx, cy):
        return x - cx, y - cy

    # Rotation helper
    def internal_renderRotate(self, x, y, theta):
        theta = math.radians(theta)
        rotatedX = math.cos(theta) * x - math.sin(theta) * y
        rotatedY = math.sin(theta) * x + math.cos(theta) * y
        return rotatedX, rotatedY

    # Scale helper
    def internal_renderScale(self, x, y):
        return x * self.scale, y * self.scale

    # Turning to screen coordinate helper
    def internal_renderScreenshift(self, x, y):
        return self.renderOrigin[0] + x, self.renderOrigin[1] - y
    
    
    # SCALE
    # Changes screen scale based on current state of self.scaleChangeDirection
    def stepScale(self):
        scaleMax = 10
        scaleMin = 0.2
        # Short circuit if it's even relevant, then ensure within bounds
        if (self.scaleChangeDirection != 0 and
            (self.scaleChangeDirection == 1 and self.scale < scaleMax) or 
            (self.scaleChangeDirection == -1 and self.scale > scaleMin)):
                scaleFactor = 1 + (0.1 * self.scaleChangeDirection)
                self.scale *= scaleFactor

render = Render(app)

# === EVENT HANDLING ===

# STEP

def onStep(app):
    if not app.paused:
        takeStep(app)

def takeStep(app):
    for path in OrbitPath.Instances + RotatingPath.Instances:
        path.step()

    for body in SmallBody.Instances:
        body.step(app)
    
    for planet in Planet.Instances:
        planet.step()

    # Rendering
    render.step(app)

# KEY INPUT

def onKeyPress(app, key):
    player.thrustKeysPressed(key)
    player.generalKeysPressed(app, key)

    if key == 'p':
        app.paused = not app.paused
    if app.paused and key == 'o':
        takeStep(app)

def onKeyHold(app, key):
    player.thrustKeysHeld(key)
    player.generalKeysHeld(app, key)

def onKeyRelease(app, key):
    player.thrustKeysReleased()
    player.generalKeysReleased(app, key)

# DRAWING

def redrawAll(app): 
    render.setRenderOrigin(app)

    # Game objects
    for objectClass in [SmallBody, Planet]:
        for instance in objectClass.Instances:
            instance.draw(app)

    if not app.debugPrint: # Threshold beyond which all is debug material
        return
    
    # Debug objects
    for objectClass in [Helperball, Helperline]:
        for instance in objectClass.Instances:
            instance.draw(app)
    
    # Velocity line
    velocityLineStartRadius = 60
    velocityLineLengthMultiplier = 10

    velocityLineStart = render.getCoords( 
        vector.add(
            player.pos, 
            vector.scale( vector.unit(player.vel), velocityLineStartRadius)
        )
    )
    velocityLineEnd = render.getCoords(
        vector.add(
            vector.add(player.pos, vector.scale(vector.unit(player.vel), velocityLineStartRadius) ),
            vector.scale(player.vel, velocityLineLengthMultiplier)
        )
    )
    #drawLine(*render.getCoords(player.pos), *velocityLineStart, fill = 'green', dashes = True)
    drawLine(*velocityLineStart, *velocityLineEnd, fill = 'red')
    
    # Planet centerlines
    for thisPlanet in Planet.Instances:
        playerCoords = render.getCoords(player.pos)
        planetCoords = render.getCoords(thisPlanet.pos)
        drawLine(*playerCoords, *planetCoords, fill = 'blue')

    drawLabel(f"Thrust: {player.thrust}", 100, 30, align = 'left')
    xThrust = math.sin(math.radians(player.pos[2]))
    yThrust = math.cos(math.radians(player.pos[2]))
    drawLabel(f"Angle Components: {xThrust}, {yThrust}", 100, 110, align = 'left')

    drawLabel(f"Speed: {player.vel}", 100, 50, align = 'left')
    trueSpeed = mymath.hypotenuse(player.vel[0], player.vel[1])
    drawLabel(f"Absolute Speed:{trueSpeed}", 100, 70, align = 'left')

    drawLabel(f"Pos: {player.pos}", 100, 90, align = 'left')

    drawLabel(f"Scale: {render.scale}", 100, 130, align = 'left')

# === APP INITIALIZATION ===

def debugGamut(app):
    barrierString = '====='.join('#.#.#.#.#.#.#.#'.split('.'))

    print(barrierString)
    for objectClass in [Helperball, Helperline, SmallBody, Planet]:
        print("Now calling objects of", objectClass)
        for instance in objectClass.Instances:
            print(instance)
        print()
    print(barrierString)
    app.isTheGravityOn = False

def onAppStart(app):
    debugGamut(app)

    RotatingPath.initalize()
    OrbitPath.initalize()
    # Game state
    app.stepsPerSecond = 30
    app.paused = False
    app.bigG = 2
    app.debugPrint = True

# === MAIN ===

def main():
    scale = 600
    runApp(width = scale, height = scale)

main()